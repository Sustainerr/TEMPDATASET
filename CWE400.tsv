1	CWE400_Resource_Exhaustion__connect_socket_for_loop_01_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_01_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_01_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_02_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 se...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRES...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRES...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_02_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_03_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADD...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADD...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_03_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_04_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_04_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_05_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;          ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_05_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_06_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_06_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_07_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_07_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_08_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET; ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_08_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_09_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_09_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_10_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;          ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_10_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_11_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET; ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_11_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_12_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_ad...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     else     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_12_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_13_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_13_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_14_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_14_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_15_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_15_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_16_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDR...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }         break;     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_16_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_17_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr...
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_17_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_18_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectS...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_18_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_21_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_21_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_21_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_22_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_22_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_22_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_22_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_for_loop_22_badGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodB2G2Global)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_for_loop_22_goodG2BGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_31_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_31_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_31_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_32_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, si...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_32_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (s...
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connec...
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_34_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_34_bad() {     int count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_a...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_por...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_34_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_41_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_41_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_41_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)     ...
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_42_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_42_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)   ...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_44_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(I...
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_44_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_for_loop_45_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_45_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_45_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_for_loop_45_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_for_loop_45_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_45_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_51_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_51_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_51_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_51b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_51b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_51b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_51b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_51b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_51b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_52_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_52_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_52_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_52b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_52b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_52b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_52b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_52c_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_53_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_53_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_53b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_53b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_53b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_53d_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_54_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_54b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_54e_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_61_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_61_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_badSource	int CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_goodG2BSource	int CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_goodB2GSource	int CWE400_Resource_Exhaustion__connect_socket_for_loop_61b_goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct socka...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSource	void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)          ...
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)      ...
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_63_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_63_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_63_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_63b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_63b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_63b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_64_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_64_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_64_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_64b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_64b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_64b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_65_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF...
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);         ...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_65_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_65b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_66_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(T...
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSoc...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_66_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_66b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_66b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_66b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_67_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_67_bad() {     int count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_p...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_67_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_67b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_67b_badSink(CWE400_Resource_Exhaustion__connect_socket_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_67b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_67b_goodG2BSink(CWE400_Resource_Exhaustion__connect_socket_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_67b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_67b_goodB2GSink(CWE400_Resource_Exhaustion__connect_socket_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_68_bad	void CWE400_Resource_Exhaustion__connect_socket_for_loop_68_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_68_goodG2BData = count;     CWE400_Resource_Exhaustion__connect_socket_for_loop_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_68_good	void CWE400_Resource_Exhaustion__connect_socket_for_loop_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_68b_badSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_68b_badSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_for_loop_68_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_68b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_for_loop_68_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_68b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_for_loop_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_for_loop_68_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, ...
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(conn...
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (str...
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectS...
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (...
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(conne...
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_for_loop_81_bad::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_for_loop_81_goodB2G::action(int count) const {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_for_loop_81_goodG2B::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, s...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__connect_socket_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__connect_socket_for_loop_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	action	void CWE400_Resource_Exhaustion__connect_socket_for_loop_82_bad::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_for_loop_82_goodB2G::action(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_for_loop_82_goodG2B::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, s...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__connect_socket_for_loop_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_bad	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_bad::CWE400_Resource_Exhaustion__connect_socket_for_loop_83_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port...
1	~CWE400_Resource_Exhaustion__connect_socket_for_loop_83_bad	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_bad::~CWE400_Resource_Exhaustion__connect_socket_for_loop_83_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodB2G::CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service....
0	~CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodB2G::~CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodG2B::CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodG2B::~CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_for_loop_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_for_loop_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_bad	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_bad::CWE400_Resource_Exhaustion__connect_socket_for_loop_84_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port...
1	~CWE400_Resource_Exhaustion__connect_socket_for_loop_84_bad	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_bad::~CWE400_Resource_Exhaustion__connect_socket_for_loop_84_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodB2G::CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service....
0	~CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodB2G::~CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodG2B::CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodG2B::~CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_for_loop_84_bad * badObject = new CWE400_Resource_Exhaustion__connect_socket_for_loop_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__connect_socket_for_loop_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_01_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_01_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_01_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_02_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 serv...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRES...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRES...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_02_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_03_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 s...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADD...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADD...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)   ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_03_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_04_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;     ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_04_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_05_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;            ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_05_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_06_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;  ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_06_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_07_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;         ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_07_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_08_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_08_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_09_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;     ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_09_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_10_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;            ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_10_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_11_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_11_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_12_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_I...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_ad...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_12_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_13_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;  ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_13_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_14_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;         ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_14_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_15_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_15_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_16_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 s...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDR...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }         break;     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_16_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_17_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family =...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr...
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_17_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_18_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(T...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectS...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_18_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_21_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_21_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_21_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_22_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_22_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_22_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_22_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_fwrite_22_badGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodB2G2Global)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_fwrite_22_goodG2BGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_31_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_31_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_31_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_32_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, size...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {     ...
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_32_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (s...
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connec...
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_34_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_34_bad() {     int count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pF...
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port ...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_34_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_41_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_41_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_41_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)     ...
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_42_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_42_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)   ...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_44_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_...
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_44_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_fwrite_45_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_45_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_45_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_fwrite_45_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_fwrite_45_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_45_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_51_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_51_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_51_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_51b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_51b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_51b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_51b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_51b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_51b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_52_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_52_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_52_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_52b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_52b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_52b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_52b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_52c_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_53_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_53_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_53b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_53b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_53b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_53d_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_54_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_54b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_54e_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_61_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_61_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_badSource	int CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_goodG2BSource	int CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_goodB2GSource	int CWE400_Resource_Exhaustion__connect_socket_fwrite_61b_goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockadd...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSource	void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)          ...
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)      ...
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_63_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_63_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_63_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_63b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_63b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_63b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_64_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_64_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_64_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_64b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_64b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_64b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_65_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INE...
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);           ...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_65_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_65b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_66_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP...
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSoc...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_66_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_66b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_66b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_66b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_67_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_67_bad() {     int count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_add...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_por...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_67_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_67b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_67b_badSink(CWE400_Resource_Exhaustion__connect_socket_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_67b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_67b_goodG2BSink(CWE400_Resource_Exhaustion__connect_socket_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_67b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_67b_goodB2GSink(CWE400_Resource_Exhaustion__connect_socket_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_68_bad	void CWE400_Resource_Exhaustion__connect_socket_fwrite_68_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_68_goodG2BData = count;     CWE400_Resource_Exhaustion__connect_socket_fwrite_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_68_good	void CWE400_Resource_Exhaustion__connect_socket_fwrite_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_68b_badSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_68b_badSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_fwrite_68_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_68b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_fwrite_68_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_68b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_fwrite_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_fwrite_68_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, ...
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(conn...
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (str...
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectS...
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (...
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(conne...
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_fwrite_81_bad::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_fwrite_81_goodB2G::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_fwrite_81_goodG2B::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, s...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__connect_socket_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__connect_socket_fwrite_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	action	void CWE400_Resource_Exhaustion__connect_socket_fwrite_82_bad::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_fwrite_82_goodB2G::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_fwrite_82_goodG2B::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, s...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__connect_socket_fwrite_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_bad	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_bad::CWE400_Resource_Exhaustion__connect_socket_fwrite_83_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = h...
1	~CWE400_Resource_Exhaustion__connect_socket_fwrite_83_bad	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_bad::~CWE400_Resource_Exhaustion__connect_socket_fwrite_83_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodB2G::CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_...
0	~CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodB2G::~CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodG2B::CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodG2B::~CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_fwrite_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_fwrite_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_bad	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_bad::CWE400_Resource_Exhaustion__connect_socket_fwrite_84_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = h...
1	~CWE400_Resource_Exhaustion__connect_socket_fwrite_84_bad	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_bad::~CWE400_Resource_Exhaustion__connect_socket_fwrite_84_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodB2G::CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_...
0	~CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodB2G::~CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodG2B::CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodG2B::~CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_fwrite_84_bad * badObject = new CWE400_Resource_Exhaustion__connect_socket_fwrite_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__connect_socket_fwrite_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_01_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_01_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_01_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_02_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 servi...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRES...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRES...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_02_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_03_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 se...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADD...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADD...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_03_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_04_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;      ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_04_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_05_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;             ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_05_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_06_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_06_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_07_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;          ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_07_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_08_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_08_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_09_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;      ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ine...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_09_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_10_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;             ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_10_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_11_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = i...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_11_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_12_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_ad...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     }     else     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_12_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_13_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_13_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_14_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;          ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_ad...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_14_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_15_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = h...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_15_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_16_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 se...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDR...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_16_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_17_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = ...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr...
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_17_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_18_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TC...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectS...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_18_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_21_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_21_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_21_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_22_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_22_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_22_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_22_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_sleep_22_badGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodB2G2Global)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__connect_socket_sleep_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_31_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_31_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_31_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_32_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeo...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_32_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (s...
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connec...
1	CWE400_Resource_Exhaustion__connect_socket_sleep_34_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_34_bad() {     int count;     CWE400_Resource_Exhaustion__connect_socket_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__connect_socket_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__connect_socket_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port =...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_34_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_41_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_41_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_41_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)     ...
1	CWE400_Resource_Exhaustion__connect_socket_sleep_42_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static int goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_42_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)   ...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_44_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_A...
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_44_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_sleep_45_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_45_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_45_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_sleep_45_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_sleep_45_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_45_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_51_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_51_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_51_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_51b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_51b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_51b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_51b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_51b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_51b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_52_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_52_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_52_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_52b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_52b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_52b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_52b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_52c_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_52c_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_52c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_52c_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_52c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_52c_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_53_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_53_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_53_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_53b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_53b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_53b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_53c_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53c_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_53c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_53c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_53d_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53d_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_53d_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53d_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_53d_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_53d_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_54_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_54_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_54b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54b_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_54c_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54c_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54c_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54c_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_54d_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54d_badSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54d_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54d_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__connect_socket_sleep_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_54e_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54e_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54e_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54e_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_54e_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_54e_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_61_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_sleep_61b_badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_sleep_61b_goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__connect_socket_sleep_61b_goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_61_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_61b_badSource	int CWE400_Resource_Exhaustion__connect_socket_sleep_61b_badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&s...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_61b_goodG2BSource	int CWE400_Resource_Exhaustion__connect_socket_sleep_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_61b_goodB2GSource	int CWE400_Resource_Exhaustion__connect_socket_sleep_61b_goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSource	void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)          ...
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)      ...
1	CWE400_Resource_Exhaustion__connect_socket_sleep_63_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_63_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_63_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_63b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_63b_badSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_63b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_63b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_64_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_64_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_64_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_64b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_64b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_64b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_65_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_sleep_65b_badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;...
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_sleep_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__connect_socket_sleep_65b_goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);            ...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_65_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_65b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_65b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_65b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_65b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_65b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_65b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_66_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_...
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__connect_socket_sleep_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSoc...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_66_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_66b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_66b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_66b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_67_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_67_bad() {     int count;     CWE400_Resource_Exhaustion__connect_socket_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__connect_socket_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__connect_socket_sleep_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__connect_socket_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_67_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_67b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_67b_badSink(CWE400_Resource_Exhaustion__connect_socket_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_67b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_67b_goodG2BSink(CWE400_Resource_Exhaustion__connect_socket_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_67b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_67b_goodB2GSink(CWE400_Resource_Exhaustion__connect_socket_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_68_bad	void CWE400_Resource_Exhaustion__connect_socket_sleep_68_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_68_goodG2BData = count;     CWE400_Resource_Exhaustion__connect_socket_sleep_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	CWE400_Resource_Exhaustion__connect_socket_sleep_68_good	void CWE400_Resource_Exhaustion__connect_socket_sleep_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_68b_badSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_68b_badSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_sleep_68_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_68b_goodG2BSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_sleep_68_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_68b_goodB2GSink	void CWE400_Resource_Exhaustion__connect_socket_sleep_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__connect_socket_sleep_68_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, ...
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(conn...
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (str...
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectS...
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (...
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(conne...
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_sleep_81_bad::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__connect_socket_sleep_81_goodB2G::action(int count) const {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_sleep_81_goodG2B::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, s...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__connect_socket_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__connect_socket_sleep_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
0	action	void CWE400_Resource_Exhaustion__connect_socket_sleep_82_bad::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__connect_socket_sleep_82_goodB2G::action(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__connect_socket_sleep_82_goodG2B::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, s...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__connect_socket_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__connect_socket_sleep_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)...
1	CWE400_Resource_Exhaustion__connect_socket_sleep_83_bad	CWE400_Resource_Exhaustion__connect_socket_sleep_83_bad::CWE400_Resource_Exhaustion__connect_socket_sleep_83_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = hto...
1	~CWE400_Resource_Exhaustion__connect_socket_sleep_83_bad	CWE400_Resource_Exhaustion__connect_socket_sleep_83_bad::~CWE400_Resource_Exhaustion__connect_socket_sleep_83_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodB2G	CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodB2G::CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_po...
0	~CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodB2G	CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodB2G::~CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodG2B	CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodG2B::CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodG2B	CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodG2B::~CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_sleep_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_sleep_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__connect_socket_sleep_84_bad	CWE400_Resource_Exhaustion__connect_socket_sleep_84_bad::CWE400_Resource_Exhaustion__connect_socket_sleep_84_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = hto...
1	~CWE400_Resource_Exhaustion__connect_socket_sleep_84_bad	CWE400_Resource_Exhaustion__connect_socket_sleep_84_bad::~CWE400_Resource_Exhaustion__connect_socket_sleep_84_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodB2G	CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodB2G::CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_po...
0	~CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodB2G	CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodB2G::~CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodG2B	CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodG2B::CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodG2B	CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodG2B::~CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_sleep_84_bad * badObject = new CWE400_Resource_Exhaustion__connect_socket_sleep_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__connect_socket_sleep_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__fgets_for_loop_01_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_01_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_01_good	void CWE400_Resource_Exhaustion__fgets_for_loop_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_02_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         } ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(1)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_02_good	void CWE400_Resource_Exhaustion__fgets_for_loop_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_03_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }     ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_03_good	void CWE400_Resource_Exhaustion__fgets_for_loop_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_04_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");          ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_04_good	void CWE400_Resource_Exhaustion__fgets_for_loop_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_05_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }      ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticTrue)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_05_good	void CWE400_Resource_Exhaustion__fgets_for_loop_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_06_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");     ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_06_good	void CWE400_Resource_Exhaustion__fgets_for_loop_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_07_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 } ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_07_good	void CWE400_Resource_Exhaustion__fgets_for_loop_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_08_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");      ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_08_good	void CWE400_Resource_Exhaustion__fgets_for_loop_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_09_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");          ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_09_good	void CWE400_Resource_Exhaustion__fgets_for_loop_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_10_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }      ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalTrue)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_10_good	void CWE400_Resource_Exhaustion__fgets_for_loop_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_11_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");      ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_11_good	void CWE400_Resource_Exhaustion__fgets_for_loop_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_12_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     else     {         {      ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalRetu...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     else     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_12_good	void CWE400_Resource_Exhaustion__fgets_for_loop_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_13_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");     ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_13_good	void CWE400_Resource_Exhaustion__fgets_for_loop_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_14_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 } ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_14_good	void CWE400_Resource_Exhaustion__fgets_for_loop_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_15_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the c...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     break;     default:         /* INCIDENTAL:...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_15_good	void CWE400_Resource_Exhaustion__fgets_for_loop_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_16_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     while(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }         break;     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     while(1)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }         break;     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }         break;     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_16_good	void CWE400_Resource_Exhaustion__fgets_for_loop_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_17_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     for(k = 0; k < 1; k++)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_17_good	void CWE400_Resource_Exhaustion__fgets_for_loop_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_18_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goto sink; sink:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goto sink; sink:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_18_good	void CWE400_Resource_Exhaustion__fgets_for_loop_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_21_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_21_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_21_good	void CWE400_Resource_Exhaustion__fgets_for_loop_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_22_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_22_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fgets_for_loop_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fgets_for_loop_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_22_good	void CWE400_Resource_Exhaustion__fgets_for_loop_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_22_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__fgets_for_loop_22_badGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__fgets_for_loop_22_goodB2G2Global)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_22_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__fgets_for_loop_22_goodG2BGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_31_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_31_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_31_good	void CWE400_Resource_Exhaustion__fgets_for_loop_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_32_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_32_good	void CWE400_Resource_Exhaustion__fgets_for_loop_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int count = countRef;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int count = countRef;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_34_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_34_bad() {     int count;     CWE400_Resource_Exhaustion__fgets_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fgets_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fgets_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_34_good	void CWE400_Resource_Exhaustion__fgets_for_loop_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_41_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_41_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_41_good	void CWE400_Resource_Exhaustion__fgets_for_loop_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
1	CWE400_Resource_Exhaustion__fgets_for_loop_42_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_42_good	void CWE400_Resource_Exhaustion__fgets_for_loop_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_44_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_44_good	void CWE400_Resource_Exhaustion__fgets_for_loop_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__fgets_for_loop_45_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_45_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_45_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fgets_for_loop_45_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fgets_for_loop_45_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_45_good	void CWE400_Resource_Exhaustion__fgets_for_loop_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_51_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_51_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_51_good	void CWE400_Resource_Exhaustion__fgets_for_loop_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_51b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_51b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_51b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_51b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_51b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_51b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_52_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_52_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_52_good	void CWE400_Resource_Exhaustion__fgets_for_loop_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_52b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_52b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_52b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_52b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_52c_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_52c_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_52c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_52c_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_52c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_52c_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_53_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_53_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_53_good	void CWE400_Resource_Exhaustion__fgets_for_loop_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_53b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_53b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_53b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_53c_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53c_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_53c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_53c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_53d_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53d_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_53d_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53d_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_53d_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_53d_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_54_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_54_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54_good	void CWE400_Resource_Exhaustion__fgets_for_loop_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_54b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_54c_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54c_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_54d_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54d_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54d_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54d_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_for_loop_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_54e_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54e_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54e_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54e_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_54e_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_54e_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_61_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_for_loop_61b_badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_for_loop_61b_goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_for_loop_61b_goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_61_good	void CWE400_Resource_Exhaustion__fgets_for_loop_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_61b_badSource	int CWE400_Resource_Exhaustion__fgets_for_loop_61b_badSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
0	CWE400_Resource_Exhaustion__fgets_for_loop_61b_goodG2BSource	int CWE400_Resource_Exhaustion__fgets_for_loop_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__fgets_for_loop_61b_goodB2GSource	int CWE400_Resource_Exhaustion__fgets_for_loop_61b_goodB2GSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSource	void badSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_63_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_63_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_63_good	void CWE400_Resource_Exhaustion__fgets_for_loop_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_63b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_63b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_63b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_64_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_64_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_64_good	void CWE400_Resource_Exhaustion__fgets_for_loop_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_64b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_64b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_64b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_65_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_for_loop_65b_badSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_for_loop_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_for_loop_65b_goodB2GSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_65_good	void CWE400_Resource_Exhaustion__fgets_for_loop_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_65b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_65b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_65b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_65b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_65b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_65b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_66_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_for_loop_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_for_loop_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_for_loop_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_66_good	void CWE400_Resource_Exhaustion__fgets_for_loop_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_66b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_66b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_66b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_67_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_67_bad() {     int count;     CWE400_Resource_Exhaustion__fgets_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_for_loop_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fgets_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_for_loop_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fgets_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_for_loop_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_67_good	void CWE400_Resource_Exhaustion__fgets_for_loop_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_67b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_67b_badSink(CWE400_Resource_Exhaustion__fgets_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_67b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_67b_goodG2BSink(CWE400_Resource_Exhaustion__fgets_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_67b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_67b_goodB2GSink(CWE400_Resource_Exhaustion__fgets_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_for_loop_68_bad	void CWE400_Resource_Exhaustion__fgets_for_loop_68_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_68_badData = count;     CWE400_Resource_Exhaustion__fgets_for_loop_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_68_goodG2BData = count;     CWE400_Resource_Exhaustion__fgets_for_loop_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_68_goodB2GData = count;     CWE400_Resource_Exhaustion__fgets_for_loop_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fgets_for_loop_68_good	void CWE400_Resource_Exhaustion__fgets_for_loop_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_68b_badSink	void CWE400_Resource_Exhaustion__fgets_for_loop_68b_badSink() {     int count = CWE400_Resource_Exhaustion__fgets_for_loop_68_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_68b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_for_loop_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fgets_for_loop_68_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_68b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_for_loop_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fgets_for_loop_68_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_for_loop_81_bad::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_for_loop_81_goodB2G::action(int count) const {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_for_loop_81_goodG2B::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE400_Resource_Exhaustion__fgets_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_for_loop_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__fgets_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_for_loop_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE400_Resource_Exhaustion__fgets_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_for_loop_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__fgets_for_loop_82_bad::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_for_loop_82_goodB2G::action(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_for_loop_82_goodG2B::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_for_loop_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_for_loop_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_for_loop_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__fgets_for_loop_83_bad	CWE400_Resource_Exhaustion__fgets_for_loop_83_bad::CWE400_Resource_Exhaustion__fgets_for_loop_83_bad(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE400_Resource_Exhaustion__fgets_for_loop_83_bad	CWE400_Resource_Exhaustion__fgets_for_loop_83_bad::~CWE400_Resource_Exhaustion__fgets_for_loop_83_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__fgets_for_loop_83_goodB2G::CWE400_Resource_Exhaustion__fgets_for_loop_83_goodB2G(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	~CWE400_Resource_Exhaustion__fgets_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__fgets_for_loop_83_goodB2G::~CWE400_Resource_Exhaustion__fgets_for_loop_83_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__fgets_for_loop_83_goodG2B::CWE400_Resource_Exhaustion__fgets_for_loop_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fgets_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__fgets_for_loop_83_goodG2B::~CWE400_Resource_Exhaustion__fgets_for_loop_83_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_for_loop_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_for_loop_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_for_loop_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__fgets_for_loop_84_bad	CWE400_Resource_Exhaustion__fgets_for_loop_84_bad::CWE400_Resource_Exhaustion__fgets_for_loop_84_bad(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE400_Resource_Exhaustion__fgets_for_loop_84_bad	CWE400_Resource_Exhaustion__fgets_for_loop_84_bad::~CWE400_Resource_Exhaustion__fgets_for_loop_84_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__fgets_for_loop_84_goodB2G::CWE400_Resource_Exhaustion__fgets_for_loop_84_goodB2G(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	~CWE400_Resource_Exhaustion__fgets_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__fgets_for_loop_84_goodB2G::~CWE400_Resource_Exhaustion__fgets_for_loop_84_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__fgets_for_loop_84_goodG2B::CWE400_Resource_Exhaustion__fgets_for_loop_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fgets_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__fgets_for_loop_84_goodG2B::~CWE400_Resource_Exhaustion__fgets_for_loop_84_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_for_loop_84_bad * badObject = new CWE400_Resource_Exhaustion__fgets_for_loop_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_for_loop_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__fgets_for_loop_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_for_loop_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__fgets_for_loop_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__fgets_fwrite_01_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_01_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {    ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);           ...
0	CWE400_Resource_Exhaustion__fgets_fwrite_01_good	void CWE400_Resource_Exhaustion__fgets_fwrite_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_02_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (s...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+"); ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_02_good	void CWE400_Resource_Exhaustion__fgets_fwrite_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_03_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)   ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_03_good	void CWE400_Resource_Exhaustion__fgets_fwrite_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_04_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large *...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {               ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }        ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_04_good	void CWE400_Resource_Exhaustion__fgets_fwrite_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_05_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fope...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_05_good	void CWE400_Resource_Exhaustion__fgets_fwrite_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_06_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very l...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {          ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }  ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_06_good	void CWE400_Resource_Exhaustion__fgets_fwrite_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_07_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */       ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile =...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_07_good	void CWE400_Resource_Exhaustion__fgets_fwrite_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_08_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very lar...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {           ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_08_good	void CWE400_Resource_Exhaustion__fgets_fwrite_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_09_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large *...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {               ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }        ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_09_good	void CWE400_Resource_Exhaustion__fgets_fwrite_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_10_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fope...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_10_good	void CWE400_Resource_Exhaustion__fgets_fwrite_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_11_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very lar...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {           ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_11_good	void CWE400_Resource_Exhaustion__fgets_fwrite_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_12_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop u...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalRetu...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	CWE400_Resource_Exhaustion__fgets_fwrite_12_good	void CWE400_Resource_Exhaustion__fgets_fwrite_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_13_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very l...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {          ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }  ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_13_good	void CWE400_Resource_Exhaustion__fgets_fwrite_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_14_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */       ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile =...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_14_good	void CWE400_Resource_Exhaustion__fgets_fwrite_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_15_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no valid...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant t...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	CWE400_Resource_Exhaustion__fgets_fwrite_15_good	void CWE400_Resource_Exhaustion__fgets_fwrite_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_16_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */          ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }         break;     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_16_good	void CWE400_Resource_Exhaustion__fgets_fwrite_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_17_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to beco...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     for(k = 0; k < 1; k++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);            ...
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_17_good	void CWE400_Resource_Exhaustion__fgets_fwrite_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_18_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char),...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_18_good	void CWE400_Resource_Exhaustion__fgets_fwrite_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_21_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_21_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_21_good	void CWE400_Resource_Exhaustion__fgets_fwrite_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_22_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_22_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fgets_fwrite_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fgets_fwrite_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_22_good	void CWE400_Resource_Exhaustion__fgets_fwrite_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_22_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__fgets_fwrite_22_badGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);           ...
0	CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__fgets_fwrite_22_goodB2G2Global)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_22_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__fgets_fwrite_22_goodG2BGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_31_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_31_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)     ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)           ...
0	CWE400_Resource_Exhaustion__fgets_fwrite_31_good	void CWE400_Resource_Exhaustion__fgets_fwrite_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_32_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {     ...
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");           ...
0	CWE400_Resource_Exhaustion__fgets_fwrite_32_good	void CWE400_Resource_Exhaustion__fgets_fwrite_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) !=...
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                ...
1	CWE400_Resource_Exhaustion__fgets_fwrite_34_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_34_bad() {     int count;     CWE400_Resource_Exhaustion__fgets_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a fil...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fgets_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);    ...
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fgets_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);   ...
0	CWE400_Resource_Exhaustion__fgets_fwrite_34_good	void CWE400_Resource_Exhaustion__fgets_fwrite_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_41_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_41_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_41_good	void CWE400_Resource_Exhaustion__fgets_fwrite_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
1	CWE400_Resource_Exhaustion__fgets_fwrite_42_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_42_good	void CWE400_Resource_Exhaustion__fgets_fwrite_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_44_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_44_good	void CWE400_Resource_Exhaustion__fgets_fwrite_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__fgets_fwrite_45_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_45_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_45_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fgets_fwrite_45_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fgets_fwrite_45_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_45_good	void CWE400_Resource_Exhaustion__fgets_fwrite_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_51_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_51_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_51_good	void CWE400_Resource_Exhaustion__fgets_fwrite_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_51b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_51b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_51b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_51b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_51b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_51b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_52_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_52_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_52_good	void CWE400_Resource_Exhaustion__fgets_fwrite_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_52b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_52b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_52b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_52b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_52c_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_52c_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_52c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_52c_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_52c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_52c_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_53_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_53_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_53_good	void CWE400_Resource_Exhaustion__fgets_fwrite_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_53b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_53b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_53b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_53c_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53c_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_53c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_53c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_53d_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53d_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_53d_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53d_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_53d_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_53d_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_54_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_54_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54_good	void CWE400_Resource_Exhaustion__fgets_fwrite_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_54b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_54c_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54c_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_54d_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54d_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54d_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54d_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_fwrite_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_54e_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54e_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54e_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54e_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_54e_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_54e_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_61_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_fwrite_61b_badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_fwrite_61b_goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_fwrite_61b_goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_61_good	void CWE400_Resource_Exhaustion__fgets_fwrite_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_61b_badSource	int CWE400_Resource_Exhaustion__fgets_fwrite_61b_badSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
0	CWE400_Resource_Exhaustion__fgets_fwrite_61b_goodG2BSource	int CWE400_Resource_Exhaustion__fgets_fwrite_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__fgets_fwrite_61b_goodB2GSource	int CWE400_Resource_Exhaustion__fgets_fwrite_61b_goodB2GSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSource	void badSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_63_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_63_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_63_good	void CWE400_Resource_Exhaustion__fgets_fwrite_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_63b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_63b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_63b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_64_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_64_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_64_good	void CWE400_Resource_Exhaustion__fgets_fwrite_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_64b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_64b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_64b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_65_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_fwrite_65b_badSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_fwrite_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_fwrite_65b_goodB2GSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_65_good	void CWE400_Resource_Exhaustion__fgets_fwrite_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_65b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_65b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_65b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_65b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_65b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_65b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_66_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_fwrite_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_fwrite_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_fwrite_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_66_good	void CWE400_Resource_Exhaustion__fgets_fwrite_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_66b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_66b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_66b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_67_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_67_bad() {     int count;     CWE400_Resource_Exhaustion__fgets_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_fwrite_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fgets_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_fwrite_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fgets_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_fwrite_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_67_good	void CWE400_Resource_Exhaustion__fgets_fwrite_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_67b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_67b_badSink(CWE400_Resource_Exhaustion__fgets_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_67b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_67b_goodG2BSink(CWE400_Resource_Exhaustion__fgets_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_67b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_67b_goodB2GSink(CWE400_Resource_Exhaustion__fgets_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fgets_fwrite_68_bad	void CWE400_Resource_Exhaustion__fgets_fwrite_68_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_68_badData = count;     CWE400_Resource_Exhaustion__fgets_fwrite_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_68_goodG2BData = count;     CWE400_Resource_Exhaustion__fgets_fwrite_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_68_goodB2GData = count;     CWE400_Resource_Exhaustion__fgets_fwrite_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fgets_fwrite_68_good	void CWE400_Resource_Exhaustion__fgets_fwrite_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_68b_badSink	void CWE400_Resource_Exhaustion__fgets_fwrite_68b_badSink() {     int count = CWE400_Resource_Exhaustion__fgets_fwrite_68_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_68b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_fwrite_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fgets_fwrite_68_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_68b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_fwrite_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fgets_fwrite_68_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_fwrite_81_bad::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_fwrite_81_goodB2G::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_fwrite_81_goodG2B::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE400_Resource_Exhaustion__fgets_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_fwrite_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__fgets_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_fwrite_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE400_Resource_Exhaustion__fgets_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_fwrite_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__fgets_fwrite_82_bad::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_fwrite_82_goodB2G::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fgets_fwrite_82_goodG2B::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_fwrite_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_fwrite_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_fwrite_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__fgets_fwrite_83_bad	CWE400_Resource_Exhaustion__fgets_fwrite_83_bad::CWE400_Resource_Exhaustion__fgets_fwrite_83_bad(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE400_Resource_Exhaustion__fgets_fwrite_83_bad	CWE400_Resource_Exhaustion__fgets_fwrite_83_bad::~CWE400_Resource_Exhaustion__fgets_fwrite_83_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__fgets_fwrite_83_goodB2G::CWE400_Resource_Exhaustion__fgets_fwrite_83_goodB2G(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	~CWE400_Resource_Exhaustion__fgets_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__fgets_fwrite_83_goodB2G::~CWE400_Resource_Exhaustion__fgets_fwrite_83_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__fgets_fwrite_83_goodG2B::CWE400_Resource_Exhaustion__fgets_fwrite_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fgets_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__fgets_fwrite_83_goodG2B::~CWE400_Resource_Exhaustion__fgets_fwrite_83_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_fwrite_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_fwrite_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_fwrite_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__fgets_fwrite_84_bad	CWE400_Resource_Exhaustion__fgets_fwrite_84_bad::CWE400_Resource_Exhaustion__fgets_fwrite_84_bad(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE400_Resource_Exhaustion__fgets_fwrite_84_bad	CWE400_Resource_Exhaustion__fgets_fwrite_84_bad::~CWE400_Resource_Exhaustion__fgets_fwrite_84_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__fgets_fwrite_84_goodB2G::CWE400_Resource_Exhaustion__fgets_fwrite_84_goodB2G(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	~CWE400_Resource_Exhaustion__fgets_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__fgets_fwrite_84_goodB2G::~CWE400_Resource_Exhaustion__fgets_fwrite_84_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fgets_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__fgets_fwrite_84_goodG2B::CWE400_Resource_Exhaustion__fgets_fwrite_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fgets_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__fgets_fwrite_84_goodG2B::~CWE400_Resource_Exhaustion__fgets_fwrite_84_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_fwrite_84_bad * badObject = new CWE400_Resource_Exhaustion__fgets_fwrite_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_fwrite_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__fgets_fwrite_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_fwrite_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__fgets_fwrite_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__fgets_sleep_01_bad	void CWE400_Resource_Exhaustion__fgets_sleep_01_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_01_good	void CWE400_Resource_Exhaustion__fgets_sleep_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_02_bad	void CWE400_Resource_Exhaustion__fgets_sleep_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(1)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_02_good	void CWE400_Resource_Exhaustion__fgets_sleep_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_03_bad	void CWE400_Resource_Exhaustion__fgets_sleep_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(5==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_03_good	void CWE400_Resource_Exhaustion__fgets_sleep_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_04_bad	void CWE400_Resource_Exhaustion__fgets_sleep_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");        ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_TRUE)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_04_good	void CWE400_Resource_Exhaustion__fgets_sleep_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_05_bad	void CWE400_Resource_Exhaustion__fgets_sleep_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticTrue)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_05_good	void CWE400_Resource_Exhaustion__fgets_sleep_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_06_bad	void CWE400_Resource_Exhaustion__fgets_sleep_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");   ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_06_good	void CWE400_Resource_Exhaustion__fgets_sleep_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_07_bad	void CWE400_Resource_Exhaustion__fgets_sleep_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticFive==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_07_good	void CWE400_Resource_Exhaustion__fgets_sleep_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_08_bad	void CWE400_Resource_Exhaustion__fgets_sleep_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");    ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(staticReturnsTrue())     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_08_good	void CWE400_Resource_Exhaustion__fgets_sleep_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_09_bad	void CWE400_Resource_Exhaustion__fgets_sleep_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");        ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_09_good	void CWE400_Resource_Exhaustion__fgets_sleep_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_10_bad	void CWE400_Resource_Exhaustion__fgets_sleep_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalTrue)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_10_good	void CWE400_Resource_Exhaustion__fgets_sleep_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_11_bad	void CWE400_Resource_Exhaustion__fgets_sleep_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");    ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalReturnsTrue())     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_11_good	void CWE400_Resource_Exhaustion__fgets_sleep_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_12_bad	void CWE400_Resource_Exhaustion__fgets_sleep_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (coun...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalRetu...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     }     else     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_12_good	void CWE400_Resource_Exhaustion__fgets_sleep_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_13_bad	void CWE400_Resource_Exhaustion__fgets_sleep_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");   ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_13_good	void CWE400_Resource_Exhaustion__fgets_sleep_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_14_bad	void CWE400_Resource_Exhaustion__fgets_sleep_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     if(globalFive==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_14_good	void CWE400_Resource_Exhaustion__fgets_sleep_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_15_bad	void CWE400_Resource_Exhaustion__fgets_sleep_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benig...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             pri...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }         break;     default:     ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_15_good	void CWE400_Resource_Exhaustion__fgets_sleep_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_16_bad	void CWE400_Resource_Exhaustion__fgets_sleep_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     while(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     while(1)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }         break;     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_16_good	void CWE400_Resource_Exhaustion__fgets_sleep_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_17_bad	void CWE400_Resource_Exhaustion__fgets_sleep_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     for(k = 0; k < 1; k++)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_17_good	void CWE400_Resource_Exhaustion__fgets_sleep_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_18_bad	void CWE400_Resource_Exhaustion__fgets_sleep_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goto sink; sink:     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goto sink; sink:     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_18_good	void CWE400_Resource_Exhaustion__fgets_sleep_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_21_bad	void CWE400_Resource_Exhaustion__fgets_sleep_21_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_21_good	void CWE400_Resource_Exhaustion__fgets_sleep_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_22_bad	void CWE400_Resource_Exhaustion__fgets_sleep_22_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fgets_sleep_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fgets_sleep_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_22_good	void CWE400_Resource_Exhaustion__fgets_sleep_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_22_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__fgets_sleep_22_badGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__fgets_sleep_22_goodB2G2Global)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_22_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__fgets_sleep_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_31_bad	void CWE400_Resource_Exhaustion__fgets_sleep_31_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int countCopy = count;         int count = countCopy;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int countCopy = count;         int count = countCopy;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_31_good	void CWE400_Resource_Exhaustion__fgets_sleep_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_32_bad	void CWE400_Resource_Exhaustion__fgets_sleep_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *countPtr1 = count;     }     {         int count = *countPtr2;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read count from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 count = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *countPtr1 = count;     }     {         int count = *countPtr2;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_32_good	void CWE400_Resource_Exhaustion__fgets_sleep_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int count = countRef;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int count = countRef;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_34_bad	void CWE400_Resource_Exhaustion__fgets_sleep_34_bad() {     int count;     CWE400_Resource_Exhaustion__fgets_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fgets_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fgets_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_34_good	void CWE400_Resource_Exhaustion__fgets_sleep_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__fgets_sleep_41_bad	void CWE400_Resource_Exhaustion__fgets_sleep_41_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_41_good	void CWE400_Resource_Exhaustion__fgets_sleep_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
1	CWE400_Resource_Exhaustion__fgets_sleep_42_bad	void CWE400_Resource_Exhaustion__fgets_sleep_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static int goodB2GSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_42_good	void CWE400_Resource_Exhaustion__fgets_sleep_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static void goodB2GSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__fgets_sleep_44_bad	void CWE400_Resource_Exhaustion__fgets_sleep_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_44_good	void CWE400_Resource_Exhaustion__fgets_sleep_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__fgets_sleep_45_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__fgets_sleep_45_bad	void CWE400_Resource_Exhaustion__fgets_sleep_45_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fgets_sleep_45_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fgets_sleep_45_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fgets_sleep_45_good	void CWE400_Resource_Exhaustion__fgets_sleep_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_51_bad	void CWE400_Resource_Exhaustion__fgets_sleep_51_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_51_good	void CWE400_Resource_Exhaustion__fgets_sleep_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_51b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_51b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_51b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_51b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_51b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_51b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_52_bad	void CWE400_Resource_Exhaustion__fgets_sleep_52_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_52_good	void CWE400_Resource_Exhaustion__fgets_sleep_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_52b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_52b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_52b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_52b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_sleep_52c_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_52c_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_52c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_52c_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_52c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_52c_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_53_bad	void CWE400_Resource_Exhaustion__fgets_sleep_53_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_53_good	void CWE400_Resource_Exhaustion__fgets_sleep_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_53b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_53b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_53b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_53b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_sleep_53c_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_53c_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_53c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_53c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_sleep_53d_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_53d_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_53d_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_53d_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_53d_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_53d_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_54_bad	void CWE400_Resource_Exhaustion__fgets_sleep_54_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54_good	void CWE400_Resource_Exhaustion__fgets_sleep_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_54b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_54b_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_sleep_54c_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_54c_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54c_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54c_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_sleep_54d_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_54d_badSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54d_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54d_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fgets_sleep_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fgets_sleep_54e_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_54e_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54e_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_54e_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_54e_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_54e_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_61_bad	void CWE400_Resource_Exhaustion__fgets_sleep_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_sleep_61b_badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_sleep_61b_goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fgets_sleep_61b_goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_61_good	void CWE400_Resource_Exhaustion__fgets_sleep_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_61b_badSource	int CWE400_Resource_Exhaustion__fgets_sleep_61b_badSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
0	CWE400_Resource_Exhaustion__fgets_sleep_61b_goodG2BSource	int CWE400_Resource_Exhaustion__fgets_sleep_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__fgets_sleep_61b_goodB2GSource	int CWE400_Resource_Exhaustion__fgets_sleep_61b_goodB2GSource(int count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSource	void badSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_63_bad	void CWE400_Resource_Exhaustion__fgets_sleep_63_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_63_good	void CWE400_Resource_Exhaustion__fgets_sleep_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_63b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_63b_badSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_63b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_63b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_64_bad	void CWE400_Resource_Exhaustion__fgets_sleep_64_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_64_good	void CWE400_Resource_Exhaustion__fgets_sleep_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_64b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_64b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_64b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_65_bad	void CWE400_Resource_Exhaustion__fgets_sleep_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_sleep_65b_badSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_sleep_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fgets_sleep_65b_goodB2GSink;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fgets_sleep_65_good	void CWE400_Resource_Exhaustion__fgets_sleep_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_65b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_65b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_65b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_65b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_65b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_65b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_66_bad	void CWE400_Resource_Exhaustion__fgets_sleep_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_sleep_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_sleep_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countArray[2] = count;     CWE400_Resource_Exhaustion__fgets_sleep_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__fgets_sleep_66_good	void CWE400_Resource_Exhaustion__fgets_sleep_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_66b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_66b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_66b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_67_bad	void CWE400_Resource_Exhaustion__fgets_sleep_67_bad() {     int count;     CWE400_Resource_Exhaustion__fgets_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_sleep_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fgets_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_sleep_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fgets_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fgets_sleep_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__fgets_sleep_67_good	void CWE400_Resource_Exhaustion__fgets_sleep_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_67b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_67b_badSink(CWE400_Resource_Exhaustion__fgets_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_67b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_67b_goodG2BSink(CWE400_Resource_Exhaustion__fgets_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_67b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_67b_goodB2GSink(CWE400_Resource_Exhaustion__fgets_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fgets_sleep_68_bad	void CWE400_Resource_Exhaustion__fgets_sleep_68_bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_68_badData = count;     CWE400_Resource_Exhaustion__fgets_sleep_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_68_goodG2BData = count;     CWE400_Resource_Exhaustion__fgets_sleep_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_68_goodB2GData = count;     CWE400_Resource_Exhaustion__fgets_sleep_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fgets_sleep_68_good	void CWE400_Resource_Exhaustion__fgets_sleep_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fgets_sleep_68b_badSink	void CWE400_Resource_Exhaustion__fgets_sleep_68b_badSink() {     int count = CWE400_Resource_Exhaustion__fgets_sleep_68_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_68b_goodG2BSink	void CWE400_Resource_Exhaustion__fgets_sleep_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fgets_sleep_68_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_68b_goodB2GSink	void CWE400_Resource_Exhaustion__fgets_sleep_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fgets_sleep_68_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__fgets_sleep_81_bad::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__fgets_sleep_81_goodB2G::action(int count) const {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__fgets_sleep_81_goodG2B::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE400_Resource_Exhaustion__fgets_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_sleep_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__fgets_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_sleep_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE400_Resource_Exhaustion__fgets_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__fgets_sleep_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__fgets_sleep_82_bad::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__fgets_sleep_82_goodB2G::action(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__fgets_sleep_82_goodG2B::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_sleep_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fgets_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_sleep_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE400_Resource_Exhaustion__fgets_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_sleep_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__fgets_sleep_83_bad	CWE400_Resource_Exhaustion__fgets_sleep_83_bad::CWE400_Resource_Exhaustion__fgets_sleep_83_bad(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE400_Resource_Exhaustion__fgets_sleep_83_bad	CWE400_Resource_Exhaustion__fgets_sleep_83_bad::~CWE400_Resource_Exhaustion__fgets_sleep_83_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_83_goodB2G	CWE400_Resource_Exhaustion__fgets_sleep_83_goodB2G::CWE400_Resource_Exhaustion__fgets_sleep_83_goodB2G(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	~CWE400_Resource_Exhaustion__fgets_sleep_83_goodB2G	CWE400_Resource_Exhaustion__fgets_sleep_83_goodB2G::~CWE400_Resource_Exhaustion__fgets_sleep_83_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_83_goodG2B	CWE400_Resource_Exhaustion__fgets_sleep_83_goodG2B::CWE400_Resource_Exhaustion__fgets_sleep_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fgets_sleep_83_goodG2B	CWE400_Resource_Exhaustion__fgets_sleep_83_goodG2B::~CWE400_Resource_Exhaustion__fgets_sleep_83_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_sleep_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_sleep_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_sleep_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__fgets_sleep_84_bad	CWE400_Resource_Exhaustion__fgets_sleep_84_bad::CWE400_Resource_Exhaustion__fgets_sleep_84_bad(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE400_Resource_Exhaustion__fgets_sleep_84_bad	CWE400_Resource_Exhaustion__fgets_sleep_84_bad::~CWE400_Resource_Exhaustion__fgets_sleep_84_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fgets_sleep_84_goodB2G	CWE400_Resource_Exhaustion__fgets_sleep_84_goodB2G::CWE400_Resource_Exhaustion__fgets_sleep_84_goodB2G(int countCopy) {     count = countCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read count from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             count = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	~CWE400_Resource_Exhaustion__fgets_sleep_84_goodB2G	CWE400_Resource_Exhaustion__fgets_sleep_84_goodB2G::~CWE400_Resource_Exhaustion__fgets_sleep_84_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fgets_sleep_84_goodG2B	CWE400_Resource_Exhaustion__fgets_sleep_84_goodG2B::CWE400_Resource_Exhaustion__fgets_sleep_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fgets_sleep_84_goodG2B	CWE400_Resource_Exhaustion__fgets_sleep_84_goodG2B::~CWE400_Resource_Exhaustion__fgets_sleep_84_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_sleep_84_bad * badObject = new CWE400_Resource_Exhaustion__fgets_sleep_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_sleep_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__fgets_sleep_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fgets_sleep_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__fgets_sleep_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_01_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_01_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_01_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_02_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(1)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_02_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_03_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_03_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_04_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_04_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_05_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticTrue)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_05_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_06_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_06_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_07_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_07_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_08_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_08_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_09_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_09_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_10_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalTrue)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_10_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_11_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_11_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_12_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }        ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     else     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {    ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     else     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_12_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_13_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_13_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_14_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_14_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_15_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     break;     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_15_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_16_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     }     while(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }         break;     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     }     while(1)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }         break;     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }         break;     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_16_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_17_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     for(k = 0; k < 1; k++)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_17_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_18_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goto sink; sink:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goto sink; sink:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_18_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_21_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_21_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_21_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_22_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_22_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_22_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Global)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_31_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_31_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_31_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_32_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_32_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int count = countRef;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int count = countRef;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_34_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_34_bad() {     int count;     CWE400_Resource_Exhaustion__fscanf_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fscanf_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fscanf_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_34_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_41_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_41_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_41_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_42_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_42_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_44_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_44_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__fscanf_for_loop_45_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_45_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_45_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fscanf_for_loop_45_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fscanf_for_loop_45_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_45_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_51_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_51_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_51_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_51b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_51b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_51b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_51b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_51b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_51b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_52_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_52_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_52_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_52b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_52b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_52b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_52b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_52c_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_52c_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_52c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_52c_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_52c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_52c_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_53_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_53_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_53_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_53b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_53b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_53b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_53c_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53c_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_53c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_53c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_53d_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53d_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_53d_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53d_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_53d_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_53d_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_54_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_54_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_54b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_54c_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54c_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_54d_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54d_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54d_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54d_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_for_loop_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_54e_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54e_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54e_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54e_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_54e_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_54e_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_61_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_for_loop_61b_badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_for_loop_61b_goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_for_loop_61b_goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_61_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_61b_badSource	int CWE400_Resource_Exhaustion__fscanf_for_loop_61b_badSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_61b_goodG2BSource	int CWE400_Resource_Exhaustion__fscanf_for_loop_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_61b_goodB2GSource	int CWE400_Resource_Exhaustion__fscanf_for_loop_61b_goodB2GSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSource	void badSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_63_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_63_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_63_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_63b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_63b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_63b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_64_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_64_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_64_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_64b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_64b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_64b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_65_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_for_loop_65b_badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_for_loop_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_for_loop_65b_goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_65_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_65b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_65b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_65b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_65b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_65b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_65b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_66_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_66_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_67_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_67_bad() {     int count;     CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_67_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodG2BSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodB2GSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_68_bad	void CWE400_Resource_Exhaustion__fscanf_for_loop_68_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_68_badData = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_68_goodG2BData = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_68_goodB2GData = count;     CWE400_Resource_Exhaustion__fscanf_for_loop_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_68_good	void CWE400_Resource_Exhaustion__fscanf_for_loop_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_68b_badSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_68b_badSink() {     int count = CWE400_Resource_Exhaustion__fscanf_for_loop_68_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_68b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fscanf_for_loop_68_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_68b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_for_loop_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fscanf_for_loop_68_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_for_loop_81_bad::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_for_loop_81_goodB2G::action(int count) const {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_for_loop_81_goodG2B::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     const CWE400_Resource_Exhaustion__fscanf_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_for_loop_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__fscanf_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_for_loop_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     const CWE400_Resource_Exhaustion__fscanf_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_for_loop_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__fscanf_for_loop_82_bad::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_for_loop_82_goodB2G::action(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_for_loop_82_goodG2B::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_83_bad	CWE400_Resource_Exhaustion__fscanf_for_loop_83_bad::CWE400_Resource_Exhaustion__fscanf_for_loop_83_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	~CWE400_Resource_Exhaustion__fscanf_for_loop_83_bad	CWE400_Resource_Exhaustion__fscanf_for_loop_83_bad::~CWE400_Resource_Exhaustion__fscanf_for_loop_83_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G::CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	~CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G::~CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodG2B::CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodG2B::~CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_for_loop_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__fscanf_for_loop_84_bad	CWE400_Resource_Exhaustion__fscanf_for_loop_84_bad::CWE400_Resource_Exhaustion__fscanf_for_loop_84_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	~CWE400_Resource_Exhaustion__fscanf_for_loop_84_bad	CWE400_Resource_Exhaustion__fscanf_for_loop_84_bad::~CWE400_Resource_Exhaustion__fscanf_for_loop_84_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G::CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	~CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G::~CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodG2B::CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodG2B::~CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_for_loop_84_bad * badObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_01_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_01_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_01_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_02_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }        ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_02_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_03_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }  ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)   ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_03_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_04_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFil...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) e...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }   ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_04_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_05_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);           ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_05_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_06_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclos...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFil...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }           ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_06_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_07_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);     ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);  ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         } ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_07_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_08_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_08_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_09_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFil...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) e...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }   ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_09_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_10_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);           ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_10_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_11_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_11_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_12_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                  ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     else     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), p...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	CWE400_Resource_Exhaustion__fscanf_fwrite_12_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_13_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclos...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFil...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }           ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_13_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_14_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);     ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);  ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         } ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_14_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_15_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)      ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (p...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	CWE400_Resource_Exhaustion__fscanf_fwrite_15_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_16_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);        ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }         break;     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_16_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_17_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {             ...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     for(k = 0; k < 1; k++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }   ...
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_17_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_18_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_18_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_21_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_21_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_21_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_22_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_22_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_fwrite_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_22_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_22_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_fwrite_22_badGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);         ...
0	CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodB2G2Global)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_fwrite_22_goodG2BGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_31_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_31_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);       ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }    ...
0	CWE400_Resource_Exhaustion__fscanf_fwrite_31_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_32_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1)...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {     ...
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 i...
0	CWE400_Resource_Exhaustion__fscanf_fwrite_32_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_34_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_34_bad() {     int count;     CWE400_Resource_Exhaustion__fscanf_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }          ...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fscanf_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);   ...
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fscanf_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {  ...
0	CWE400_Resource_Exhaustion__fscanf_fwrite_34_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_41_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_41_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_41_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_42_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_42_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_44_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_44_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__fscanf_fwrite_45_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_45_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_45_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fscanf_fwrite_45_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fscanf_fwrite_45_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_45_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_51_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_51_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_51_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_51b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_51b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_51b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_51b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_51b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_51b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_52_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_52_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_52_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_52c_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_52c_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_52c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_52c_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_52c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_52c_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_53_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_53_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_53_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_53b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_53b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_53b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_53c_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53c_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_53c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_53c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_53d_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53d_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_53d_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53d_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_53d_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_53d_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_54_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_54_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_54b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_54c_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54c_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_54d_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54d_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54d_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54d_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_fwrite_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_54e_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54e_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54e_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54e_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_54e_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_54e_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_61_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_fwrite_61b_badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_fwrite_61b_goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_fwrite_61b_goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_61_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_61b_badSource	int CWE400_Resource_Exhaustion__fscanf_fwrite_61b_badSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_61b_goodG2BSource	int CWE400_Resource_Exhaustion__fscanf_fwrite_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_61b_goodB2GSource	int CWE400_Resource_Exhaustion__fscanf_fwrite_61b_goodB2GSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSource	void badSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_63_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_63_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_63_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_63b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_63b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_63b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_64_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_64_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_64_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_64b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_64b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_64b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_65_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_fwrite_65b_badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_fwrite_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_fwrite_65b_goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_65_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_65b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_65b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_65b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_65b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_65b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_65b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_66_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_66_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_66b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_66b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_66b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_67_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_67_bad() {     int count;     CWE400_Resource_Exhaustion__fscanf_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fscanf_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fscanf_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_67_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_67b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_67b_badSink(CWE400_Resource_Exhaustion__fscanf_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_67b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_67b_goodG2BSink(CWE400_Resource_Exhaustion__fscanf_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_67b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_67b_goodB2GSink(CWE400_Resource_Exhaustion__fscanf_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_68_bad	void CWE400_Resource_Exhaustion__fscanf_fwrite_68_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_68_badData = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_68_goodG2BData = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_68_goodB2GData = count;     CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_68_good	void CWE400_Resource_Exhaustion__fscanf_fwrite_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink() {     int count = CWE400_Resource_Exhaustion__fscanf_fwrite_68_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fscanf_fwrite_68_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fscanf_fwrite_68_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_fwrite_81_bad::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_fwrite_81_goodB2G::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_fwrite_81_goodG2B::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     const CWE400_Resource_Exhaustion__fscanf_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_fwrite_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__fscanf_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_fwrite_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     const CWE400_Resource_Exhaustion__fscanf_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_fwrite_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__fscanf_fwrite_82_bad::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_fwrite_82_goodB2G::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_fwrite_82_goodG2B::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_fwrite_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_fwrite_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_fwrite_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad	CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad::CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	~CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad	CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad::~CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodB2G::CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	~CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodB2G::~CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B::CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B::~CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__fscanf_fwrite_84_bad	CWE400_Resource_Exhaustion__fscanf_fwrite_84_bad::CWE400_Resource_Exhaustion__fscanf_fwrite_84_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	~CWE400_Resource_Exhaustion__fscanf_fwrite_84_bad	CWE400_Resource_Exhaustion__fscanf_fwrite_84_bad::~CWE400_Resource_Exhaustion__fscanf_fwrite_84_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodB2G::CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	~CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodB2G::~CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodG2B::CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodG2B::~CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_fwrite_84_bad * badObject = new CWE400_Resource_Exhaustion__fscanf_fwrite_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__fscanf_fwrite_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__fscanf_sleep_01_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_01_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_01_good	void CWE400_Resource_Exhaustion__fscanf_sleep_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_02_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(1)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_02_good	void CWE400_Resource_Exhaustion__fscanf_sleep_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_03_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(5==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_03_good	void CWE400_Resource_Exhaustion__fscanf_sleep_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_04_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_04_good	void CWE400_Resource_Exhaustion__fscanf_sleep_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_05_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticTrue)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_05_good	void CWE400_Resource_Exhaustion__fscanf_sleep_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_06_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_06_good	void CWE400_Resource_Exhaustion__fscanf_sleep_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_07_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticFive==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_07_good	void CWE400_Resource_Exhaustion__fscanf_sleep_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_08_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(staticReturnsTrue())     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_08_good	void CWE400_Resource_Exhaustion__fscanf_sleep_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_09_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_09_good	void CWE400_Resource_Exhaustion__fscanf_sleep_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_10_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalTrue)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_10_good	void CWE400_Resource_Exhaustion__fscanf_sleep_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_11_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrue())     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_11_good	void CWE400_Resource_Exhaustion__fscanf_sleep_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_12_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     else     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     }     else     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_12_good	void CWE400_Resource_Exhaustion__fscanf_sleep_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_13_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_13_good	void CWE400_Resource_Exhaustion__fscanf_sleep_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_14_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     if(globalFive==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_14_good	void CWE400_Resource_Exhaustion__fscanf_sleep_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_15_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }         break;     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_15_good	void CWE400_Resource_Exhaustion__fscanf_sleep_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_16_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     }     while(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         break;     }     while(1)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }         break;     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_16_good	void CWE400_Resource_Exhaustion__fscanf_sleep_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_17_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);     }     for(k = 0; k < 1; k++)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_17_good	void CWE400_Resource_Exhaustion__fscanf_sleep_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_18_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goto sink; sink:     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goto sink; sink:     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_18_good	void CWE400_Resource_Exhaustion__fscanf_sleep_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_21_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_21_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_21_good	void CWE400_Resource_Exhaustion__fscanf_sleep_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_22_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_22_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_sleep_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__fscanf_sleep_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_22_good	void CWE400_Resource_Exhaustion__fscanf_sleep_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_22_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_sleep_22_badGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_sleep_22_goodB2G2Global)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_22_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__fscanf_sleep_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_31_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_31_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int countCopy = count;         int count = countCopy;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int countCopy = count;         int count = countCopy;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_31_good	void CWE400_Resource_Exhaustion__fscanf_sleep_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_32_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         *countPtr1 = count;     }     {         int count = *countPtr2;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Read count from the console using fscanf() */         fscanf(stdin, "%d", &count);         *countPtr1 = count;     }     {         int count = *countPtr2;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_32_good	void CWE400_Resource_Exhaustion__fscanf_sleep_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int count = countRef;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     {         int count = countRef;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_34_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_34_bad() {     int count;     CWE400_Resource_Exhaustion__fscanf_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fscanf_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fscanf_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_34_good	void CWE400_Resource_Exhaustion__fscanf_sleep_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_41_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_41_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_41_good	void CWE400_Resource_Exhaustion__fscanf_sleep_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
1	CWE400_Resource_Exhaustion__fscanf_sleep_42_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static int goodB2GSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_42_good	void CWE400_Resource_Exhaustion__fscanf_sleep_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_44_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_44_good	void CWE400_Resource_Exhaustion__fscanf_sleep_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__fscanf_sleep_45_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_45_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_45_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fscanf_sleep_45_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fscanf_sleep_45_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_45_good	void CWE400_Resource_Exhaustion__fscanf_sleep_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_51_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_51_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_51_good	void CWE400_Resource_Exhaustion__fscanf_sleep_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_52_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_52_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_52_good	void CWE400_Resource_Exhaustion__fscanf_sleep_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_52b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_52b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_52b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_52b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_52c_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_52c_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_52c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_52c_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_52c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_52c_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_53_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_53_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_53_good	void CWE400_Resource_Exhaustion__fscanf_sleep_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_53b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_53b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_53b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_53c_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53c_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_53c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_53c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_53d_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53d_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_53d_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53d_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_53d_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_53d_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_54_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_54_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54_good	void CWE400_Resource_Exhaustion__fscanf_sleep_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_54b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54b_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_54c_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54c_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54c_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54c_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_54d_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54d_badSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54d_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54d_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__fscanf_sleep_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_54e_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54e_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54e_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54e_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_54e_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_54e_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_61_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_sleep_61b_badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_sleep_61b_goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__fscanf_sleep_61b_goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_61_good	void CWE400_Resource_Exhaustion__fscanf_sleep_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_61b_badSource	int CWE400_Resource_Exhaustion__fscanf_sleep_61b_badSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
0	CWE400_Resource_Exhaustion__fscanf_sleep_61b_goodG2BSource	int CWE400_Resource_Exhaustion__fscanf_sleep_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__fscanf_sleep_61b_goodB2GSource	int CWE400_Resource_Exhaustion__fscanf_sleep_61b_goodB2GSource(int count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSource	void badSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_63_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_63_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_63_good	void CWE400_Resource_Exhaustion__fscanf_sleep_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_63b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_63b_badSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_63b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_63b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_64_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_64_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_64_good	void CWE400_Resource_Exhaustion__fscanf_sleep_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_64b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_64b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_64b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_65_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_sleep_65b_badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_sleep_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__fscanf_sleep_65b_goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     funcPtr(count); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_65_good	void CWE400_Resource_Exhaustion__fscanf_sleep_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_65b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_65b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_65b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_65b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_65b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_65b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_66_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_sleep_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_sleep_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countArray[2] = count;     CWE400_Resource_Exhaustion__fscanf_sleep_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_66_good	void CWE400_Resource_Exhaustion__fscanf_sleep_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_66b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_66b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_66b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_67_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_67_bad() {     int count;     CWE400_Resource_Exhaustion__fscanf_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_sleep_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__fscanf_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_sleep_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__fscanf_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__fscanf_sleep_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_67_good	void CWE400_Resource_Exhaustion__fscanf_sleep_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_67b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_67b_badSink(CWE400_Resource_Exhaustion__fscanf_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_67b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_67b_goodG2BSink(CWE400_Resource_Exhaustion__fscanf_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_67b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_67b_goodB2GSink(CWE400_Resource_Exhaustion__fscanf_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__fscanf_sleep_68_bad	void CWE400_Resource_Exhaustion__fscanf_sleep_68_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_68_badData = count;     CWE400_Resource_Exhaustion__fscanf_sleep_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_68_goodG2BData = count;     CWE400_Resource_Exhaustion__fscanf_sleep_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_68_goodB2GData = count;     CWE400_Resource_Exhaustion__fscanf_sleep_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_68_good	void CWE400_Resource_Exhaustion__fscanf_sleep_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_68b_badSink	void CWE400_Resource_Exhaustion__fscanf_sleep_68b_badSink() {     int count = CWE400_Resource_Exhaustion__fscanf_sleep_68_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_68b_goodG2BSink	void CWE400_Resource_Exhaustion__fscanf_sleep_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__fscanf_sleep_68_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_68b_goodB2GSink	void CWE400_Resource_Exhaustion__fscanf_sleep_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__fscanf_sleep_68_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_sleep_81_bad::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__fscanf_sleep_81_goodB2G::action(int count) const {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_sleep_81_goodG2B::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     const CWE400_Resource_Exhaustion__fscanf_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_sleep_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__fscanf_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_sleep_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     const CWE400_Resource_Exhaustion__fscanf_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__fscanf_sleep_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__fscanf_sleep_82_bad::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__fscanf_sleep_82_goodB2G::action(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__fscanf_sleep_82_goodG2B::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_sleep_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__fscanf_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_sleep_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count);     CWE400_Resource_Exhaustion__fscanf_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_sleep_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__fscanf_sleep_83_bad	CWE400_Resource_Exhaustion__fscanf_sleep_83_bad::CWE400_Resource_Exhaustion__fscanf_sleep_83_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	~CWE400_Resource_Exhaustion__fscanf_sleep_83_bad	CWE400_Resource_Exhaustion__fscanf_sleep_83_bad::~CWE400_Resource_Exhaustion__fscanf_sleep_83_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_83_goodB2G	CWE400_Resource_Exhaustion__fscanf_sleep_83_goodB2G::CWE400_Resource_Exhaustion__fscanf_sleep_83_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	~CWE400_Resource_Exhaustion__fscanf_sleep_83_goodB2G	CWE400_Resource_Exhaustion__fscanf_sleep_83_goodB2G::~CWE400_Resource_Exhaustion__fscanf_sleep_83_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_83_goodG2B	CWE400_Resource_Exhaustion__fscanf_sleep_83_goodG2B::CWE400_Resource_Exhaustion__fscanf_sleep_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fscanf_sleep_83_goodG2B	CWE400_Resource_Exhaustion__fscanf_sleep_83_goodG2B::~CWE400_Resource_Exhaustion__fscanf_sleep_83_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_sleep_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_sleep_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_sleep_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__fscanf_sleep_84_bad	CWE400_Resource_Exhaustion__fscanf_sleep_84_bad::CWE400_Resource_Exhaustion__fscanf_sleep_84_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
1	~CWE400_Resource_Exhaustion__fscanf_sleep_84_bad	CWE400_Resource_Exhaustion__fscanf_sleep_84_bad::~CWE400_Resource_Exhaustion__fscanf_sleep_84_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__fscanf_sleep_84_goodB2G	CWE400_Resource_Exhaustion__fscanf_sleep_84_goodB2G::CWE400_Resource_Exhaustion__fscanf_sleep_84_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Read count from the console using fscanf() */     fscanf(stdin, "%d", &count); }
0	~CWE400_Resource_Exhaustion__fscanf_sleep_84_goodB2G	CWE400_Resource_Exhaustion__fscanf_sleep_84_goodB2G::~CWE400_Resource_Exhaustion__fscanf_sleep_84_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__fscanf_sleep_84_goodG2B	CWE400_Resource_Exhaustion__fscanf_sleep_84_goodG2B::CWE400_Resource_Exhaustion__fscanf_sleep_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__fscanf_sleep_84_goodG2B	CWE400_Resource_Exhaustion__fscanf_sleep_84_goodG2B::~CWE400_Resource_Exhaustion__fscanf_sleep_84_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_sleep_84_bad * badObject = new CWE400_Resource_Exhaustion__fscanf_sleep_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_sleep_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__fscanf_sleep_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__fscanf_sleep_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__fscanf_sleep_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_01_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_01_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_01_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_02_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 ser...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_02_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_03_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;             ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;             ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_03_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_04_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_04_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_05_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));           ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_05_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_06_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)); ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_06_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_07_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));        ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_07_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_08_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));  ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_08_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_09_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_09_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_10_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));           ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_10_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_11_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));  ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_11_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_12_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(servi...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     else     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_12_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_13_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)); ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_13_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_14_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));        ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_14_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_15_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_15_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_16_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;              ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }         break;     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_16_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_17_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_fami...
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_17_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_18_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;       ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);  ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_18_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_21_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_21_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_21_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_22_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_22_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_22_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_22_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_for_loop_22_badGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodB2G2Global)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_for_loop_22_goodG2BGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_31_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_31_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_31_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_32_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;            ...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, ...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_32_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);           ...
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);...
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_34_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_34_bad() {     int count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;     ...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_AN...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_34_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_41_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_41_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_41_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(serv...
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_42_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_42_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, siz...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_44_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;         ...
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_44_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_for_loop_45_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_45_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_45_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_for_loop_45_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_for_loop_45_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_45_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_51_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_51_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_51_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_51b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_51b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_51b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_51b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_51b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_51b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_52_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_52_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_52_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_52b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_52b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_52b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_52b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_52c_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_53_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_53_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_53b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_53b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_53b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_53d_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_54_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_54b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_54e_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_61_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_61_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_badSource	int CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_goodG2BSource	int CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_goodB2GSource	int CWE400_Resource_Exhaustion__listen_socket_for_loop_61b_goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(l...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSource	void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service...
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(ser...
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_63_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_63_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_63_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_63b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_63b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_63b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_64_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_64_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_64_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_64b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_64b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_64b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_65_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(servic...
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_65_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_65b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_66_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;         ...
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);    ...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_66_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_66b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_66b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_66b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_67_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_67_bad() {     int count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;   ...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_67_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_67b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_67b_badSink(CWE400_Resource_Exhaustion__listen_socket_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_67b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_67b_goodG2BSink(CWE400_Resource_Exhaustion__listen_socket_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_67b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_67b_goodB2GSink(CWE400_Resource_Exhaustion__listen_socket_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_68_bad	void CWE400_Resource_Exhaustion__listen_socket_for_loop_68_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_68_goodG2BData = count;     CWE400_Resource_Exhaustion__listen_socket_for_loop_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_68_good	void CWE400_Resource_Exhaustion__listen_socket_for_loop_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_68b_badSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_68b_badSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_for_loop_68_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_68b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_for_loop_68_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_68b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_for_loop_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_for_loop_68_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);         ...
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT...
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             ...
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);  ...
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);          ...
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT)...
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_for_loop_81_bad::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_for_loop_81_goodB2G::action(int count) const {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_for_loop_81_goodG2B::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__listen_socket_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__listen_socket_for_loop_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(lis...
0	action	void CWE400_Resource_Exhaustion__listen_socket_for_loop_82_bad::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_for_loop_82_goodB2G::action(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_for_loop_82_goodG2B::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__listen_socket_for_loop_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(lis...
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_bad	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_bad::CWE400_Resource_Exhaustion__listen_socket_for_loop_83_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;...
1	~CWE400_Resource_Exhaustion__listen_socket_for_loop_83_bad	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_bad::~CWE400_Resource_Exhaustion__listen_socket_for_loop_83_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodB2G::CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INA...
0	~CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodB2G::~CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodG2B::CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodG2B::~CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_for_loop_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_for_loop_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_bad	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_bad::CWE400_Resource_Exhaustion__listen_socket_for_loop_84_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;...
1	~CWE400_Resource_Exhaustion__listen_socket_for_loop_84_bad	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_bad::~CWE400_Resource_Exhaustion__listen_socket_for_loop_84_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodB2G::CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INA...
0	~CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodB2G::~CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodG2B::CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodG2B::~CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_for_loop_84_bad * badObject = new CWE400_Resource_Exhaustion__listen_socket_for_loop_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__listen_socket_for_loop_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_01_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_01_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_01_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_02_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 servi...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_02_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_03_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 se...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;             ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;             ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)   ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_03_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_04_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));      ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_04_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_05_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));             ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_05_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_06_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_06_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_07_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));          ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_07_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_08_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_08_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_09_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));      ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_09_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_10_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));             ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_10_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_11_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_11_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_12_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_12_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_13_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_13_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_14_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));          ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_14_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_15_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;  ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_15_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_16_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 se...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;              ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }         break;     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_16_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_17_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(se...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_fami...
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_17_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_18_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;         ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);  ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_18_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_21_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_21_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_21_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_22_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_22_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_22_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_22_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_fwrite_22_badGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pF...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodB2G2Global)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_fwrite_22_goodG2BGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_31_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_31_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_31_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_32_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;              ...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {     ...
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, ...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_32_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);           ...
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);...
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_34_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_34_bad() {     int count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;         ...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFi...
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_34_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_41_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_41_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_41_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(serv...
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_42_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_42_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, siz...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_44_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;           ...
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_44_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_fwrite_45_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_45_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_45_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_fwrite_45_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_fwrite_45_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_45_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_51_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_51_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_51_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_51b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_51b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_51b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_51b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_51b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_51b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_52_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_52_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_52_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_52b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_52b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_52b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_52b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_52c_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_53_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_53_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_53b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_53b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_53b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_53d_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_54_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_54b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_54e_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_61_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_61_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_badSource	int CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenS...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_goodG2BSource	int CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_goodB2GSource	int CWE400_Resource_Exhaustion__listen_socket_fwrite_61b_goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(lis...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSource	void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service...
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(ser...
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_63_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_63_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_63_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_63b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_63b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_63b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_64_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_64_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_64_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_64b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_64b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_64b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_65_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));...
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_65_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_65b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_66_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;           ...
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);    ...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_66_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_66b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_66b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_66b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_67_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_67_bad() {     int count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;       ...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_AN...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_67_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_67b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_67b_badSink(CWE400_Resource_Exhaustion__listen_socket_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_67b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_67b_goodG2BSink(CWE400_Resource_Exhaustion__listen_socket_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_67b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_67b_goodB2GSink(CWE400_Resource_Exhaustion__listen_socket_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_68_bad	void CWE400_Resource_Exhaustion__listen_socket_fwrite_68_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_68_goodG2BData = count;     CWE400_Resource_Exhaustion__listen_socket_fwrite_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_68_good	void CWE400_Resource_Exhaustion__listen_socket_fwrite_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_68b_badSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_68b_badSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_fwrite_68_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_68b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_fwrite_68_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_68b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_fwrite_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_fwrite_68_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);         ...
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT...
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             ...
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);  ...
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);          ...
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT)...
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_fwrite_81_bad::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_fwrite_81_goodB2G::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_fwrite_81_goodG2B::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__listen_socket_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__listen_socket_fwrite_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(lis...
0	action	void CWE400_Resource_Exhaustion__listen_socket_fwrite_82_bad::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_fwrite_82_goodB2G::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_fwrite_82_goodG2B::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__listen_socket_fwrite_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(lis...
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_bad	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_bad::CWE400_Resource_Exhaustion__listen_socket_fwrite_83_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;    ...
1	~CWE400_Resource_Exhaustion__listen_socket_fwrite_83_bad	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_bad::~CWE400_Resource_Exhaustion__listen_socket_fwrite_83_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodB2G::CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_...
0	~CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodB2G::~CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodG2B::CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodG2B::~CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_fwrite_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_fwrite_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_bad	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_bad::CWE400_Resource_Exhaustion__listen_socket_fwrite_84_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;    ...
1	~CWE400_Resource_Exhaustion__listen_socket_fwrite_84_bad	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_bad::~CWE400_Resource_Exhaustion__listen_socket_fwrite_84_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodB2G::CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_...
0	~CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodB2G::~CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodG2B::CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodG2B::~CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_fwrite_84_bad * badObject = new CWE400_Resource_Exhaustion__listen_socket_fwrite_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__listen_socket_fwrite_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_01_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_01_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_01_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_02_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 servic...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_02_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_03_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 ser...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;             ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;             ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_03_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_04_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));       ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_04_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_05_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));              ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_05_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_06_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_06_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_07_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));           ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_07_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_08_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));     ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_08_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_09_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));       ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_09_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_10_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));              ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;       ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_10_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_11_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));     ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INE...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_11_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_12_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     }     else     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_12_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_13_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_13_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_14_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));           ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;    ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_14_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_15_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;   ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_15_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_16_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 ser...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;              ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_16_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_17_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(ser...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_fami...
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_17_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_18_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;          ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);  ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_18_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_21_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_21_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_21_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_22_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_22_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_22_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_22_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_sleep_22_badGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodB2G2Global)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__listen_socket_sleep_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_31_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_31_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_31_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_32_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;               ...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read count using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, ...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_32_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);           ...
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);...
1	CWE400_Resource_Exhaustion__listen_socket_sleep_34_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_34_bad() {     int count;     CWE400_Resource_Exhaustion__listen_socket_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;           ...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__listen_socket_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__listen_socket_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY; ...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_34_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_41_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_41_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_41_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(serv...
1	CWE400_Resource_Exhaustion__listen_socket_sleep_42_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static int goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_42_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, siz...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_44_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;            ...
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = ht...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_44_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_45_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_45_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_sleep_45_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_sleep_45_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_45_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_51_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_51_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_51_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_51b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_51b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_51b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_51b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_51b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_51b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_52_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_52_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_52_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_52b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_52b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_52b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_52b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_52c_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_52c_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_52c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_52c_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_52c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_52c_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_53_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_53_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_53_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_53b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_53b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_53b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_53c_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53c_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_53c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_53c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_53d_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53d_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_53d_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53d_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_53d_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_53d_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_54_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_54_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_54b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54b_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_54c_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54c_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54c_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54c_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_54d_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54d_badSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54d_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54d_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__listen_socket_sleep_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_54e_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54e_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54e_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54e_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_54e_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_54e_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_61_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_sleep_61b_badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_sleep_61b_goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__listen_socket_sleep_61b_goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_61_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_61b_badSource	int CWE400_Resource_Exhaustion__listen_socket_sleep_61b_badSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSo...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_61b_goodG2BSource	int CWE400_Resource_Exhaustion__listen_socket_sleep_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_61b_goodB2GSource	int CWE400_Resource_Exhaustion__listen_socket_sleep_61b_goodB2GSource(int count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(list...
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSource	void badSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service...
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(ser...
1	CWE400_Resource_Exhaustion__listen_socket_sleep_63_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_63_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_63_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_63b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_63b_badSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_63b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_63b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_64_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_64_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_64_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_64b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_64b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_64b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_65_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_sleep_65b_badSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));  ...
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_sleep_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_sleep_65b_goodB2GSink;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_65_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_65b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_65b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_65b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_65b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_65b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_65b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_66_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;            ...
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__listen_socket_sleep_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);    ...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_66_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_66b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_66b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_66b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_67_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_67_bad() {     int count;     CWE400_Resource_Exhaustion__listen_socket_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;         ...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__listen_socket_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__listen_socket_sleep_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__listen_socket_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_67_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_67b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_67b_badSink(CWE400_Resource_Exhaustion__listen_socket_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_67b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_67b_goodG2BSink(CWE400_Resource_Exhaustion__listen_socket_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_67b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_67b_goodB2GSink(CWE400_Resource_Exhaustion__listen_socket_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_68_bad	void CWE400_Resource_Exhaustion__listen_socket_sleep_68_bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = hto...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_68_goodG2BData = count;     CWE400_Resource_Exhaustion__listen_socket_sleep_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(liste...
0	CWE400_Resource_Exhaustion__listen_socket_sleep_68_good	void CWE400_Resource_Exhaustion__listen_socket_sleep_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_68b_badSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_68b_badSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_sleep_68_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_68b_goodG2BSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_sleep_68_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_68b_goodB2GSink	void CWE400_Resource_Exhaustion__listen_socket_sleep_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__listen_socket_sleep_68_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);         ...
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT...
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             ...
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);  ...
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);          ...
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT)...
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_sleep_81_bad::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__listen_socket_sleep_81_goodB2G::action(int count) const {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_sleep_81_goodG2B::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__listen_socket_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__listen_socket_sleep_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(lis...
0	action	void CWE400_Resource_Exhaustion__listen_socket_sleep_82_bad::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__listen_socket_sleep_82_goodB2G::action(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__listen_socket_sleep_82_goodG2B::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__listen_socket_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__listen_socket_sleep_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(lis...
1	CWE400_Resource_Exhaustion__listen_socket_sleep_83_bad	CWE400_Resource_Exhaustion__listen_socket_sleep_83_bad::CWE400_Resource_Exhaustion__listen_socket_sleep_83_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;      ...
1	~CWE400_Resource_Exhaustion__listen_socket_sleep_83_bad	CWE400_Resource_Exhaustion__listen_socket_sleep_83_bad::~CWE400_Resource_Exhaustion__listen_socket_sleep_83_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodB2G	CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodB2G::CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_AN...
0	~CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodB2G	CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodB2G::~CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodG2B	CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodG2B::CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodG2B	CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodG2B::~CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_sleep_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_sleep_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__listen_socket_sleep_84_bad	CWE400_Resource_Exhaustion__listen_socket_sleep_84_bad::CWE400_Resource_Exhaustion__listen_socket_sleep_84_bad(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;      ...
1	~CWE400_Resource_Exhaustion__listen_socket_sleep_84_bad	CWE400_Resource_Exhaustion__listen_socket_sleep_84_bad::~CWE400_Resource_Exhaustion__listen_socket_sleep_84_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodB2G	CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodB2G::CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodB2G(int countCopy) {     count = countCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read count using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_AN...
0	~CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodB2G	CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodB2G::~CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodG2B	CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodG2B::CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodG2B	CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodG2B::~CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_sleep_84_bad * badObject = new CWE400_Resource_Exhaustion__listen_socket_sleep_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__listen_socket_sleep_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__rand_for_loop_01_bad	void CWE400_Resource_Exhaustion__rand_for_loop_01_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_01_good	void CWE400_Resource_Exhaustion__rand_for_loop_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_02_bad	void CWE400_Resource_Exhaustion__rand_for_loop_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(1)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_02_good	void CWE400_Resource_Exhaustion__rand_for_loop_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_03_bad	void CWE400_Resource_Exhaustion__rand_for_loop_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_03_good	void CWE400_Resource_Exhaustion__rand_for_loop_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_04_bad	void CWE400_Resource_Exhaustion__rand_for_loop_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_04_good	void CWE400_Resource_Exhaustion__rand_for_loop_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_05_bad	void CWE400_Resource_Exhaustion__rand_for_loop_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticTrue)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_05_good	void CWE400_Resource_Exhaustion__rand_for_loop_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_06_bad	void CWE400_Resource_Exhaustion__rand_for_loop_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_06_good	void CWE400_Resource_Exhaustion__rand_for_loop_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_07_bad	void CWE400_Resource_Exhaustion__rand_for_loop_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_07_good	void CWE400_Resource_Exhaustion__rand_for_loop_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_08_bad	void CWE400_Resource_Exhaustion__rand_for_loop_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_08_good	void CWE400_Resource_Exhaustion__rand_for_loop_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_09_bad	void CWE400_Resource_Exhaustion__rand_for_loop_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_09_good	void CWE400_Resource_Exhaustion__rand_for_loop_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_10_bad	void CWE400_Resource_Exhaustion__rand_for_loop_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalTrue)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_10_good	void CWE400_Resource_Exhaustion__rand_for_loop_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_11_bad	void CWE400_Resource_Exhaustion__rand_for_loop_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_11_good	void CWE400_Resource_Exhaustion__rand_for_loop_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_12_bad	void CWE400_Resource_Exhaustion__rand_for_loop_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     else     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                ...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     else     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_12_good	void CWE400_Resource_Exhaustion__rand_for_loop_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_13_bad	void CWE400_Resource_Exhaustion__rand_for_loop_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_13_good	void CWE400_Resource_Exhaustion__rand_for_loop_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_14_bad	void CWE400_Resource_Exhaustion__rand_for_loop_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive==5)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_14_good	void CWE400_Resource_Exhaustion__rand_for_loop_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_15_bad	void CWE400_Resource_Exhaustion__rand_for_loop_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     break;     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_15_good	void CWE400_Resource_Exhaustion__rand_for_loop_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_16_bad	void CWE400_Resource_Exhaustion__rand_for_loop_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     }     while(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }         break;     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     }     while(1)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }         break;     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }         break;     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_16_good	void CWE400_Resource_Exhaustion__rand_for_loop_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_17_bad	void CWE400_Resource_Exhaustion__rand_for_loop_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     for(k = 0; k < 1; k++)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_17_good	void CWE400_Resource_Exhaustion__rand_for_loop_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_18_bad	void CWE400_Resource_Exhaustion__rand_for_loop_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goto sink; sink:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goto sink; sink:     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_18_good	void CWE400_Resource_Exhaustion__rand_for_loop_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_21_bad	void CWE400_Resource_Exhaustion__rand_for_loop_21_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_21_good	void CWE400_Resource_Exhaustion__rand_for_loop_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_22_bad	void CWE400_Resource_Exhaustion__rand_for_loop_22_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__rand_for_loop_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__rand_for_loop_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_22_good	void CWE400_Resource_Exhaustion__rand_for_loop_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_22_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__rand_for_loop_22_badGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__rand_for_loop_22_goodB2G2Global)     {         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_22_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__rand_for_loop_22_goodG2BGlobal)     {         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_31_bad	void CWE400_Resource_Exhaustion__rand_for_loop_31_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_31_good	void CWE400_Resource_Exhaustion__rand_for_loop_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_32_bad	void CWE400_Resource_Exhaustion__rand_for_loop_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_32_good	void CWE400_Resource_Exhaustion__rand_for_loop_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int count = countRef;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int count = countRef;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_34_bad	void CWE400_Resource_Exhaustion__rand_for_loop_34_bad() {     int count;     CWE400_Resource_Exhaustion__rand_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__rand_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__rand_for_loop_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             /* FIX: Validate count before using it as the for loop variant */             if (count > 0 && count <= 20)             {                 for (i = 0; i < (size_t)count; i++)                 {                     printLine("Hello");                 }             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_34_good	void CWE400_Resource_Exhaustion__rand_for_loop_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_41_bad	void CWE400_Resource_Exhaustion__rand_for_loop_41_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_41_good	void CWE400_Resource_Exhaustion__rand_for_loop_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
1	CWE400_Resource_Exhaustion__rand_for_loop_42_bad	void CWE400_Resource_Exhaustion__rand_for_loop_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_42_good	void CWE400_Resource_Exhaustion__rand_for_loop_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_44_bad	void CWE400_Resource_Exhaustion__rand_for_loop_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     funcPtr(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_44_good	void CWE400_Resource_Exhaustion__rand_for_loop_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__rand_for_loop_45_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_45_bad	void CWE400_Resource_Exhaustion__rand_for_loop_45_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__rand_for_loop_45_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__rand_for_loop_45_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__rand_for_loop_45_good	void CWE400_Resource_Exhaustion__rand_for_loop_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_51_bad	void CWE400_Resource_Exhaustion__rand_for_loop_51_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_51_good	void CWE400_Resource_Exhaustion__rand_for_loop_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_51b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_51b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_51b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_51b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_51b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_51b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_52_bad	void CWE400_Resource_Exhaustion__rand_for_loop_52_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_52_good	void CWE400_Resource_Exhaustion__rand_for_loop_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_52b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_52b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_52b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_52b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_for_loop_52c_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_52c_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_52c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_52c_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_52c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_52c_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_53_bad	void CWE400_Resource_Exhaustion__rand_for_loop_53_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_53_good	void CWE400_Resource_Exhaustion__rand_for_loop_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_53b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_53b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_53b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_53b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_for_loop_53c_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_53c_badSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_53c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_53c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_for_loop_53d_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_53d_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_53d_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_53d_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_53d_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_53d_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_54_bad	void CWE400_Resource_Exhaustion__rand_for_loop_54_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_54_good	void CWE400_Resource_Exhaustion__rand_for_loop_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_54b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_54b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_54b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_54b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_for_loop_54c_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_54c_badSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_54c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_54c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_for_loop_54d_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_54d_badSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_54d_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_54d_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_for_loop_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_for_loop_54e_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_54e_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_54e_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_54e_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_54e_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_54e_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_61_bad	void CWE400_Resource_Exhaustion__rand_for_loop_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_for_loop_61b_badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_for_loop_61b_goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_for_loop_61b_goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_61_good	void CWE400_Resource_Exhaustion__rand_for_loop_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_61b_badSource	int CWE400_Resource_Exhaustion__rand_for_loop_61b_badSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
0	CWE400_Resource_Exhaustion__rand_for_loop_61b_goodG2BSource	int CWE400_Resource_Exhaustion__rand_for_loop_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__rand_for_loop_61b_goodB2GSource	int CWE400_Resource_Exhaustion__rand_for_loop_61b_goodB2GSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	badSource	void badSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_63_bad	void CWE400_Resource_Exhaustion__rand_for_loop_63_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_63_good	void CWE400_Resource_Exhaustion__rand_for_loop_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_63b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_63b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_63b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_64_bad	void CWE400_Resource_Exhaustion__rand_for_loop_64_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_64_good	void CWE400_Resource_Exhaustion__rand_for_loop_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_64b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_64b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_64b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_65_bad	void CWE400_Resource_Exhaustion__rand_for_loop_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_for_loop_65b_badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_for_loop_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_for_loop_65b_goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     funcPtr(count); }
0	CWE400_Resource_Exhaustion__rand_for_loop_65_good	void CWE400_Resource_Exhaustion__rand_for_loop_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_65b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_65b_badSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_65b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_65b_goodG2BSink(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_65b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_65b_goodB2GSink(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_66_bad	void CWE400_Resource_Exhaustion__rand_for_loop_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_for_loop_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_for_loop_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_for_loop_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__rand_for_loop_66_good	void CWE400_Resource_Exhaustion__rand_for_loop_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_66b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_66b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_66b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_67_bad	void CWE400_Resource_Exhaustion__rand_for_loop_67_bad() {     int count;     CWE400_Resource_Exhaustion__rand_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_for_loop_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__rand_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_for_loop_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__rand_for_loop_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_for_loop_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__rand_for_loop_67_good	void CWE400_Resource_Exhaustion__rand_for_loop_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_67b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_67b_badSink(CWE400_Resource_Exhaustion__rand_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_67b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_67b_goodG2BSink(CWE400_Resource_Exhaustion__rand_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_67b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_67b_goodB2GSink(CWE400_Resource_Exhaustion__rand_for_loop_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	CWE400_Resource_Exhaustion__rand_for_loop_68_bad	void CWE400_Resource_Exhaustion__rand_for_loop_68_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_68_badData = count;     CWE400_Resource_Exhaustion__rand_for_loop_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_68_goodG2BData = count;     CWE400_Resource_Exhaustion__rand_for_loop_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_68_goodB2GData = count;     CWE400_Resource_Exhaustion__rand_for_loop_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__rand_for_loop_68_good	void CWE400_Resource_Exhaustion__rand_for_loop_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_for_loop_68b_badSink	void CWE400_Resource_Exhaustion__rand_for_loop_68b_badSink() {     int count = CWE400_Resource_Exhaustion__rand_for_loop_68_badData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_68b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_for_loop_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__rand_for_loop_68_goodG2BData;     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_68b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_for_loop_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__rand_for_loop_68_goodB2GData;     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_for_loop_81_bad::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_for_loop_81_goodB2G::action(int count) const {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_for_loop_81_goodG2B::action(int count) const {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     const CWE400_Resource_Exhaustion__rand_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__rand_for_loop_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__rand_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__rand_for_loop_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     const CWE400_Resource_Exhaustion__rand_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__rand_for_loop_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__rand_for_loop_82_bad::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_for_loop_82_goodB2G::action(int count) {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_for_loop_82_goodG2B::action(int count) {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_for_loop_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_for_loop_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_for_loop_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__rand_for_loop_83_bad	CWE400_Resource_Exhaustion__rand_for_loop_83_bad::CWE400_Resource_Exhaustion__rand_for_loop_83_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	~CWE400_Resource_Exhaustion__rand_for_loop_83_bad	CWE400_Resource_Exhaustion__rand_for_loop_83_bad::~CWE400_Resource_Exhaustion__rand_for_loop_83_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__rand_for_loop_83_goodB2G::CWE400_Resource_Exhaustion__rand_for_loop_83_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	~CWE400_Resource_Exhaustion__rand_for_loop_83_goodB2G	CWE400_Resource_Exhaustion__rand_for_loop_83_goodB2G::~CWE400_Resource_Exhaustion__rand_for_loop_83_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__rand_for_loop_83_goodG2B::CWE400_Resource_Exhaustion__rand_for_loop_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__rand_for_loop_83_goodG2B	CWE400_Resource_Exhaustion__rand_for_loop_83_goodG2B::~CWE400_Resource_Exhaustion__rand_for_loop_83_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_for_loop_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_for_loop_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_for_loop_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__rand_for_loop_84_bad	CWE400_Resource_Exhaustion__rand_for_loop_84_bad::CWE400_Resource_Exhaustion__rand_for_loop_84_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	~CWE400_Resource_Exhaustion__rand_for_loop_84_bad	CWE400_Resource_Exhaustion__rand_for_loop_84_bad::~CWE400_Resource_Exhaustion__rand_for_loop_84_bad() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__rand_for_loop_84_goodB2G::CWE400_Resource_Exhaustion__rand_for_loop_84_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	~CWE400_Resource_Exhaustion__rand_for_loop_84_goodB2G	CWE400_Resource_Exhaustion__rand_for_loop_84_goodB2G::~CWE400_Resource_Exhaustion__rand_for_loop_84_goodB2G() {     {         size_t i = 0;         /* FIX: Validate count before using it as the for loop variant */         if (count > 0 && count <= 20)         {             for (i = 0; i < (size_t)count; i++)             {                 printLine("Hello");             }         }     } }
0	CWE400_Resource_Exhaustion__rand_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__rand_for_loop_84_goodG2B::CWE400_Resource_Exhaustion__rand_for_loop_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__rand_for_loop_84_goodG2B	CWE400_Resource_Exhaustion__rand_for_loop_84_goodG2B::~CWE400_Resource_Exhaustion__rand_for_loop_84_goodG2B() {     {         size_t i = 0;         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */         for (i = 0; i < (size_t)count; i++)         {             printLine("Hello");         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_for_loop_84_bad * badObject = new CWE400_Resource_Exhaustion__rand_for_loop_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_for_loop_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__rand_for_loop_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_for_loop_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__rand_for_loop_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__rand_fwrite_01_bad	void CWE400_Resource_Exhaustion__rand_fwrite_01_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_01_good	void CWE400_Resource_Exhaustion__rand_fwrite_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_02_bad	void CWE400_Resource_Exhaustion__rand_fwrite_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)       ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_02_good	void CWE400_Resource_Exhaustion__rand_fwrite_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_03_bad	void CWE400_Resource_Exhaustion__rand_fwrite_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile) ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)   ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_03_good	void CWE400_Resource_Exhaustion__rand_fwrite_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_04_bad	void CWE400_Resource_Exhaustion__rand_fwrite_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         } ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 } ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_04_good	void CWE400_Resource_Exhaustion__rand_fwrite_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_05_bad	void CWE400_Resource_Exhaustion__rand_fwrite_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }               ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_05_good	void CWE400_Resource_Exhaustion__rand_fwrite_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_06_bad	void CWE400_Resource_Exhaustion__rand_fwrite_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }     ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);              ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_06_good	void CWE400_Resource_Exhaustion__rand_fwrite_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_07_bad	void CWE400_Resource_Exhaustion__rand_fwrite_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }          ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_07_good	void CWE400_Resource_Exhaustion__rand_fwrite_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_08_bad	void CWE400_Resource_Exhaustion__rand_fwrite_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }       ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);               ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_08_good	void CWE400_Resource_Exhaustion__rand_fwrite_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_09_bad	void CWE400_Resource_Exhaustion__rand_fwrite_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         } ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 } ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_09_good	void CWE400_Resource_Exhaustion__rand_fwrite_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_10_bad	void CWE400_Resource_Exhaustion__rand_fwrite_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }               ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_10_good	void CWE400_Resource_Exhaustion__rand_fwrite_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_11_bad	void CWE400_Resource_Exhaustion__rand_fwrite_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }       ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);               ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_11_good	void CWE400_Resource_Exhaustion__rand_fwrite_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_12_bad	void CWE400_Resource_Exhaustion__rand_fwrite_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 ...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     else     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if...
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)         ...
0	CWE400_Resource_Exhaustion__rand_fwrite_12_good	void CWE400_Resource_Exhaustion__rand_fwrite_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_13_bad	void CWE400_Resource_Exhaustion__rand_fwrite_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }     ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);              ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_13_good	void CWE400_Resource_Exhaustion__rand_fwrite_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_14_bad	void CWE400_Resource_Exhaustion__rand_fwrite_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }          ...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }        ...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_14_good	void CWE400_Resource_Exhaustion__rand_fwrite_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_15_bad	void CWE400_Resource_Exhaustion__rand_fwrite_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }    ...
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 i...
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {       ...
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(p...
0	CWE400_Resource_Exhaustion__rand_fwrite_15_good	void CWE400_Resource_Exhaustion__rand_fwrite_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_16_bad	void CWE400_Resource_Exhaustion__rand_fwrite_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }         bre...
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }         break;     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }         break;     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_16_good	void CWE400_Resource_Exhaustion__rand_fwrite_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_17_bad	void CWE400_Resource_Exhaustion__rand_fwrite_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);          ...
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     for(k = 0; k < 1; k++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_17_good	void CWE400_Resource_Exhaustion__rand_fwrite_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_18_bad	void CWE400_Resource_Exhaustion__rand_fwrite_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_18_good	void CWE400_Resource_Exhaustion__rand_fwrite_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_21_bad	void CWE400_Resource_Exhaustion__rand_fwrite_21_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_21_good	void CWE400_Resource_Exhaustion__rand_fwrite_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_22_bad	void CWE400_Resource_Exhaustion__rand_fwrite_22_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__rand_fwrite_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__rand_fwrite_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_22_good	void CWE400_Resource_Exhaustion__rand_fwrite_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_22_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__rand_fwrite_22_badGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);             ...
0	CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__rand_fwrite_22_goodB2G2Global)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_22_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__rand_fwrite_22_goodG2BGlobal)     {         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_31_bad	void CWE400_Resource_Exhaustion__rand_fwrite_31_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int countCopy = count;         int count = countCopy;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_31_good	void CWE400_Resource_Exhaustion__rand_fwrite_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_32_bad	void CWE400_Resource_Exhaustion__rand_fwrite_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }         ...
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {     ...
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         *countPtr1 = count;     }     {         int count = *countPtr2;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 ...
0	CWE400_Resource_Exhaustion__rand_fwrite_32_good	void CWE400_Resource_Exhaustion__rand_fwrite_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int count = countRef;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pFile);                 }             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_34_bad	void CWE400_Resource_Exhaustion__rand_fwrite_34_bad() {     int count;     CWE400_Resource_Exhaustion__rand_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)   ...
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__rand_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_bad.txt";             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             /* POTENTIAL FLAW: For loop using count as the loop variant and no validation              * This can cause a file to become very large */             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))                 {                     exit(1);                 }             }             if (pFile)             {                 fclose(pFile);     ...
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__rand_fwrite_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         {             size_t i = 0;             FILE *pFile = NULL;             const char *filename = "output_good.txt";             /* FIX: Validate count before using it as the for loop variant to write to a file */             if (count > 0 && count <= 20)             {                 pFile = fopen(filename, "w+");                 if (pFile == NULL)                 {                     exit(1);                 }                 for (i = 0; i < (size_t)count; i++)                 {                     if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);                 }                 if (pFile)                 {                     fclose(pF...
0	CWE400_Resource_Exhaustion__rand_fwrite_34_good	void CWE400_Resource_Exhaustion__rand_fwrite_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_41_bad	void CWE400_Resource_Exhaustion__rand_fwrite_41_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_41_good	void CWE400_Resource_Exhaustion__rand_fwrite_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
1	CWE400_Resource_Exhaustion__rand_fwrite_42_bad	void CWE400_Resource_Exhaustion__rand_fwrite_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static int goodB2GSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_42_good	void CWE400_Resource_Exhaustion__rand_fwrite_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSource	static void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSink	static void badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_44_bad	void CWE400_Resource_Exhaustion__rand_fwrite_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     funcPtr(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_44_good	void CWE400_Resource_Exhaustion__rand_fwrite_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__rand_fwrite_45_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_45_bad	void CWE400_Resource_Exhaustion__rand_fwrite_45_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__rand_fwrite_45_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__rand_fwrite_45_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__rand_fwrite_45_good	void CWE400_Resource_Exhaustion__rand_fwrite_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_51_bad	void CWE400_Resource_Exhaustion__rand_fwrite_51_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_51_good	void CWE400_Resource_Exhaustion__rand_fwrite_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_51b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_51b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_51b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_51b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_51b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_51b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_52_bad	void CWE400_Resource_Exhaustion__rand_fwrite_52_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_52_good	void CWE400_Resource_Exhaustion__rand_fwrite_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_52b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_52b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_52b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_52b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_fwrite_52c_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_52c_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_52c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_52c_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_52c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_52c_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_53_bad	void CWE400_Resource_Exhaustion__rand_fwrite_53_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_53_good	void CWE400_Resource_Exhaustion__rand_fwrite_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_53b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_53b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_53b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_53b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_fwrite_53c_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_53c_badSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_53c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_53c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_fwrite_53d_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_53d_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_53d_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_53d_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_53d_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_53d_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_54_bad	void CWE400_Resource_Exhaustion__rand_fwrite_54_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_54_good	void CWE400_Resource_Exhaustion__rand_fwrite_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_54b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_54b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_54b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_54b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_fwrite_54c_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_54c_badSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_54c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_54c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_fwrite_54d_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_54d_badSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_54d_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_54d_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_fwrite_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_fwrite_54e_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_54e_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_54e_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_54e_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_54e_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_54e_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_61_bad	void CWE400_Resource_Exhaustion__rand_fwrite_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_fwrite_61b_badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_fwrite_61b_goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_fwrite_61b_goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_61_good	void CWE400_Resource_Exhaustion__rand_fwrite_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_61b_badSource	int CWE400_Resource_Exhaustion__rand_fwrite_61b_badSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
0	CWE400_Resource_Exhaustion__rand_fwrite_61b_goodG2BSource	int CWE400_Resource_Exhaustion__rand_fwrite_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__rand_fwrite_61b_goodB2GSource	int CWE400_Resource_Exhaustion__rand_fwrite_61b_goodB2GSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	badSource	void badSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_63_bad	void CWE400_Resource_Exhaustion__rand_fwrite_63_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_63_good	void CWE400_Resource_Exhaustion__rand_fwrite_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_63b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_63b_badSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_63b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_63b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_64_bad	void CWE400_Resource_Exhaustion__rand_fwrite_64_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_64_good	void CWE400_Resource_Exhaustion__rand_fwrite_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_64b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_64b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_64b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_65_bad	void CWE400_Resource_Exhaustion__rand_fwrite_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_fwrite_65b_badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_fwrite_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_fwrite_65b_goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     funcPtr(count); }
0	CWE400_Resource_Exhaustion__rand_fwrite_65_good	void CWE400_Resource_Exhaustion__rand_fwrite_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_65b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_65b_badSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_65b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_65b_goodG2BSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_65b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_65b_goodB2GSink(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_66_bad	void CWE400_Resource_Exhaustion__rand_fwrite_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_fwrite_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_fwrite_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_fwrite_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__rand_fwrite_66_good	void CWE400_Resource_Exhaustion__rand_fwrite_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_66b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_66b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_66b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_67_bad	void CWE400_Resource_Exhaustion__rand_fwrite_67_bad() {     int count;     CWE400_Resource_Exhaustion__rand_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_fwrite_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__rand_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_fwrite_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__rand_fwrite_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_fwrite_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__rand_fwrite_67_good	void CWE400_Resource_Exhaustion__rand_fwrite_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_67b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_67b_badSink(CWE400_Resource_Exhaustion__rand_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_67b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_67b_goodG2BSink(CWE400_Resource_Exhaustion__rand_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_67b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_67b_goodB2GSink(CWE400_Resource_Exhaustion__rand_fwrite_67_structType myStruct) {     int count = myStruct.structFirst;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	CWE400_Resource_Exhaustion__rand_fwrite_68_bad	void CWE400_Resource_Exhaustion__rand_fwrite_68_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_68_badData = count;     CWE400_Resource_Exhaustion__rand_fwrite_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_68_goodG2BData = count;     CWE400_Resource_Exhaustion__rand_fwrite_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_68_goodB2GData = count;     CWE400_Resource_Exhaustion__rand_fwrite_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__rand_fwrite_68_good	void CWE400_Resource_Exhaustion__rand_fwrite_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_fwrite_68b_badSink	void CWE400_Resource_Exhaustion__rand_fwrite_68b_badSink() {     int count = CWE400_Resource_Exhaustion__rand_fwrite_68_badData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_68b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_fwrite_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__rand_fwrite_68_goodG2BData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_68b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_fwrite_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__rand_fwrite_68_goodB2GData;     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_fwrite_81_bad::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_fwrite_81_goodB2G::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_fwrite_81_goodG2B::action(int count) const {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     const CWE400_Resource_Exhaustion__rand_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__rand_fwrite_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__rand_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__rand_fwrite_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     const CWE400_Resource_Exhaustion__rand_fwrite_81_base& baseObject = CWE400_Resource_Exhaustion__rand_fwrite_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__rand_fwrite_82_bad::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_fwrite_82_goodB2G::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	action	void CWE400_Resource_Exhaustion__rand_fwrite_82_goodG2B::action(int count) {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_fwrite_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_fwrite_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_fwrite_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__rand_fwrite_83_bad	CWE400_Resource_Exhaustion__rand_fwrite_83_bad::CWE400_Resource_Exhaustion__rand_fwrite_83_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	~CWE400_Resource_Exhaustion__rand_fwrite_83_bad	CWE400_Resource_Exhaustion__rand_fwrite_83_bad::~CWE400_Resource_Exhaustion__rand_fwrite_83_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__rand_fwrite_83_goodB2G::CWE400_Resource_Exhaustion__rand_fwrite_83_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	~CWE400_Resource_Exhaustion__rand_fwrite_83_goodB2G	CWE400_Resource_Exhaustion__rand_fwrite_83_goodB2G::~CWE400_Resource_Exhaustion__rand_fwrite_83_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__rand_fwrite_83_goodG2B::CWE400_Resource_Exhaustion__rand_fwrite_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__rand_fwrite_83_goodG2B	CWE400_Resource_Exhaustion__rand_fwrite_83_goodG2B::~CWE400_Resource_Exhaustion__rand_fwrite_83_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_fwrite_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_fwrite_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_fwrite_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__rand_fwrite_84_bad	CWE400_Resource_Exhaustion__rand_fwrite_84_bad::CWE400_Resource_Exhaustion__rand_fwrite_84_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	~CWE400_Resource_Exhaustion__rand_fwrite_84_bad	CWE400_Resource_Exhaustion__rand_fwrite_84_bad::~CWE400_Resource_Exhaustion__rand_fwrite_84_bad() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__rand_fwrite_84_goodB2G::CWE400_Resource_Exhaustion__rand_fwrite_84_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	~CWE400_Resource_Exhaustion__rand_fwrite_84_goodB2G	CWE400_Resource_Exhaustion__rand_fwrite_84_goodB2G::~CWE400_Resource_Exhaustion__rand_fwrite_84_goodB2G() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_good.txt";         /* FIX: Validate count before using it as the for loop variant to write to a file */         if (count > 0 && count <= 20)         {             pFile = fopen(filename, "w+");             if (pFile == NULL)             {                 exit(1);             }             for (i = 0; i < (size_t)count; i++)             {                 if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);             }             if (pFile)             {                 fclose(pFile);             }         }     } }
0	CWE400_Resource_Exhaustion__rand_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__rand_fwrite_84_goodG2B::CWE400_Resource_Exhaustion__rand_fwrite_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__rand_fwrite_84_goodG2B	CWE400_Resource_Exhaustion__rand_fwrite_84_goodG2B::~CWE400_Resource_Exhaustion__rand_fwrite_84_goodG2B() {     {         size_t i = 0;         FILE *pFile = NULL;         const char *filename = "output_bad.txt";         pFile = fopen(filename, "w+");         if (pFile == NULL)         {             exit(1);         }         /* POTENTIAL FLAW: For loop using count as the loop variant and no validation          * This can cause a file to become very large */         for (i = 0; i < (size_t)count; i++)         {             if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))             {                 exit(1);             }         }         if (pFile)         {             fclose(pFile);         }     } }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_fwrite_84_bad * badObject = new CWE400_Resource_Exhaustion__rand_fwrite_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_fwrite_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__rand_fwrite_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_fwrite_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__rand_fwrite_84_goodB2G(count);     delete goodB2GObject; }
1	CWE400_Resource_Exhaustion__rand_sleep_01_bad	void CWE400_Resource_Exhaustion__rand_sleep_01_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_01_good	void CWE400_Resource_Exhaustion__rand_sleep_01_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_02_bad	void CWE400_Resource_Exhaustion__rand_sleep_02_bad() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(1)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(1)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_02_good	void CWE400_Resource_Exhaustion__rand_sleep_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_03_bad	void CWE400_Resource_Exhaustion__rand_sleep_03_bad() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(5==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(5==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(5==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_03_good	void CWE400_Resource_Exhaustion__rand_sleep_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_04_bad	void CWE400_Resource_Exhaustion__rand_sleep_04_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_TRUE)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_04_good	void CWE400_Resource_Exhaustion__rand_sleep_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_05_bad	void CWE400_Resource_Exhaustion__rand_sleep_05_bad() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticTrue)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_05_good	void CWE400_Resource_Exhaustion__rand_sleep_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_06_bad	void CWE400_Resource_Exhaustion__rand_sleep_06_bad() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_06_good	void CWE400_Resource_Exhaustion__rand_sleep_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_07_bad	void CWE400_Resource_Exhaustion__rand_sleep_07_bad() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticFive==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_07_good	void CWE400_Resource_Exhaustion__rand_sleep_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_08_bad	void CWE400_Resource_Exhaustion__rand_sleep_08_bad() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(staticReturnsTrue())     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(staticReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_08_good	void CWE400_Resource_Exhaustion__rand_sleep_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_09_bad	void CWE400_Resource_Exhaustion__rand_sleep_09_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_09_good	void CWE400_Resource_Exhaustion__rand_sleep_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_10_bad	void CWE400_Resource_Exhaustion__rand_sleep_10_bad() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalTrue)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalTrue)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_10_good	void CWE400_Resource_Exhaustion__rand_sleep_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_11_bad	void CWE400_Resource_Exhaustion__rand_sleep_11_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrue())     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrue())     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_11_good	void CWE400_Resource_Exhaustion__rand_sleep_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_12_bad	void CWE400_Resource_Exhaustion__rand_sleep_12_bad() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     else     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a relatively small number */         count = 20;     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     }     else     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_12_good	void CWE400_Resource_Exhaustion__rand_sleep_12_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_sleep_13_bad	void CWE400_Resource_Exhaustion__rand_sleep_13_bad() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_13_good	void CWE400_Resource_Exhaustion__rand_sleep_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_14_bad	void CWE400_Resource_Exhaustion__rand_sleep_14_bad() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     if(globalFive==5)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     if(globalFive==5)     {         /* FIX: Use a relatively small number */         count = 20;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_14_good	void CWE400_Resource_Exhaustion__rand_sleep_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_15_bad	void CWE400_Resource_Exhaustion__rand_sleep_15_bad() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }         break;     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int count;     /* Initialize count */     count = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a relatively small number */         count = 20;         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int count;     /* Initialize count */     count = -1;     switch(6)     {     case 6:         /* FIX: Use a relatively small number */         count = 20;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE400_Resource_Exhaustion__rand_sleep_15_good	void CWE400_Resource_Exhaustion__rand_sleep_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE400_Resource_Exhaustion__rand_sleep_16_bad	void CWE400_Resource_Exhaustion__rand_sleep_16_bad() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     }     while(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         break;     }     while(1)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }         break;     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     while(1)     {         /* FIX: Use a relatively small number */         count = 20;         break;     }     while(1)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");         break;     } }
0	CWE400_Resource_Exhaustion__rand_sleep_16_good	void CWE400_Resource_Exhaustion__rand_sleep_16_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_sleep_17_bad	void CWE400_Resource_Exhaustion__rand_sleep_17_bad() {     int i,j;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int i,k;     int count;     /* Initialize count */     count = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();     }     for(k = 0; k < 1; k++)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodG2B	static void goodG2B() {     int h,j;     int count;     /* Initialize count */     count = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a relatively small number */         count = 20;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_17_good	void CWE400_Resource_Exhaustion__rand_sleep_17_good() {     goodB2G();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_sleep_18_bad	void CWE400_Resource_Exhaustion__rand_sleep_18_bad() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goto sink; sink:     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goto sink; sink:     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goto source; source:     /* FIX: Use a relatively small number */     count = 20;     goto sink; sink:     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_18_good	void CWE400_Resource_Exhaustion__rand_sleep_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int count) {     if(badStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_21_bad	void CWE400_Resource_Exhaustion__rand_sleep_21_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     badStatic = 1; /* true */     badSink(count); }
0	goodB2G1Sink	static void goodB2G1Sink(int count) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2G1Static = 0; /* false */     goodB2G1Sink(count); }
0	goodB2G2Sink	static void goodB2G2Sink(int count) {     if(goodB2G2Static)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2G2Static = 1; /* true */     goodB2G2Sink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BStatic = 1; /* true */     goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_21_good	void CWE400_Resource_Exhaustion__rand_sleep_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_sleep_22_bad	void CWE400_Resource_Exhaustion__rand_sleep_22_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_22_badGlobal = 1; /* true */     CWE400_Resource_Exhaustion__rand_sleep_22_badSink(count); }
0	goodB2G1	static void goodB2G1() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G1Global = 0; /* false */     CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G1Sink(count); }
0	goodB2G2	static void goodB2G2() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G2Global = 1; /* true */     CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G2Sink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_22_goodG2BGlobal = 1; /* true */     CWE400_Resource_Exhaustion__rand_sleep_22_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_22_good	void CWE400_Resource_Exhaustion__rand_sleep_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE400_Resource_Exhaustion__rand_sleep_22_badSink	void CWE400_Resource_Exhaustion__rand_sleep_22_badSink(int count) {     if(CWE400_Resource_Exhaustion__rand_sleep_22_badGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G1Sink	void CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G1Sink(int count) {     if(CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G2Sink	void CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G2Sink(int count) {     if(CWE400_Resource_Exhaustion__rand_sleep_22_goodB2G2Global)     {         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__rand_sleep_22_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_22_goodG2BSink(int count) {     if(CWE400_Resource_Exhaustion__rand_sleep_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_31_bad	void CWE400_Resource_Exhaustion__rand_sleep_31_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int countCopy = count;         int count = countCopy;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int countCopy = count;         int count = countCopy;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int countCopy = count;         int count = countCopy;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__rand_sleep_31_good	void CWE400_Resource_Exhaustion__rand_sleep_31_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_32_bad	void CWE400_Resource_Exhaustion__rand_sleep_32_bad() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         *countPtr1 = count;     }     {         int count = *countPtr2;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* FIX: Use a relatively small number */         count = 20;         *countPtr1 = count;     }     {         int count = *countPtr2;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int *countPtr1 = &count;     int *countPtr2 = &count;     /* Initialize count */     count = -1;     {         int count = *countPtr1;         /* POTENTIAL FLAW: Set count to a random value */         count = RAND32();         *countPtr1 = count;     }     {         int count = *countPtr2;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__rand_sleep_32_good	void CWE400_Resource_Exhaustion__rand_sleep_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int count = countRef;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     {         int count = countRef;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     int &countRef = count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     {         int count = countRef;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
1	CWE400_Resource_Exhaustion__rand_sleep_34_bad	void CWE400_Resource_Exhaustion__rand_sleep_34_bad() {     int count;     CWE400_Resource_Exhaustion__rand_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__rand_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */         SLEEP(count);         printLine("Sleep time possibly too long");     } }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__rand_sleep_34_unionType myUnion;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myUnion.unionFirst = count;     {         int count = myUnion.unionSecond;         /* FIX: Validate count before using it as a parameter in the sleep function */         if (count > 0 && count <= 2000)         {             SLEEP(count);             printLine("Sleep time OK");         }         else         {             printLine("Sleep time too long");         }     } }
0	CWE400_Resource_Exhaustion__rand_sleep_34_good	void CWE400_Resource_Exhaustion__rand_sleep_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__rand_sleep_41_bad	void CWE400_Resource_Exhaustion__rand_sleep_41_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     badSink(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     goodG2BSink(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_41_good	void CWE400_Resource_Exhaustion__rand_sleep_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int badSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
1	CWE400_Resource_Exhaustion__rand_sleep_42_bad	void CWE400_Resource_Exhaustion__rand_sleep_42_bad() {     int count;     /* Initialize count */     count = -1;     count = badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static int goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static int goodB2GSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_42_good	void CWE400_Resource_Exhaustion__rand_sleep_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSource	static void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSource	static void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSink	static void badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__rand_sleep_44_bad	void CWE400_Resource_Exhaustion__rand_sleep_44_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* use the function pointer */     funcPtr(count); }
0	goodG2BSink	static void goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2GSink	static void goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     funcPtr(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_44_good	void CWE400_Resource_Exhaustion__rand_sleep_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int count = CWE400_Resource_Exhaustion__rand_sleep_45_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	CWE400_Resource_Exhaustion__rand_sleep_45_bad	void CWE400_Resource_Exhaustion__rand_sleep_45_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_45_badData = count;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int count = CWE400_Resource_Exhaustion__rand_sleep_45_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_45_goodG2BData = count;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int count = CWE400_Resource_Exhaustion__rand_sleep_45_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_45_goodB2GData = count;     goodB2GSink(); }
0	CWE400_Resource_Exhaustion__rand_sleep_45_good	void CWE400_Resource_Exhaustion__rand_sleep_45_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_51_bad	void CWE400_Resource_Exhaustion__rand_sleep_51_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_51b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_51b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_51b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_51_good	void CWE400_Resource_Exhaustion__rand_sleep_51_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_51b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_51b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_51b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_51b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_51b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_51b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_52_bad	void CWE400_Resource_Exhaustion__rand_sleep_52_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_52b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_52b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_52b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_52_good	void CWE400_Resource_Exhaustion__rand_sleep_52_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_52b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_52b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_52c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_52b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_52b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_52c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_52b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_52b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_52c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_sleep_52c_badSink	void CWE400_Resource_Exhaustion__rand_sleep_52c_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_52c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_52c_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_52c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_52c_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_53_bad	void CWE400_Resource_Exhaustion__rand_sleep_53_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_53b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_53b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_53b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_53_good	void CWE400_Resource_Exhaustion__rand_sleep_53_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_53b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_53b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_53c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_53b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_53b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_53c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_53b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_53b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_53c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_sleep_53c_badSink	void CWE400_Resource_Exhaustion__rand_sleep_53c_badSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_53d_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_53c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_53c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_53d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_53c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_53c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_53d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_sleep_53d_badSink	void CWE400_Resource_Exhaustion__rand_sleep_53d_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_53d_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_53d_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_53d_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_53d_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_54_bad	void CWE400_Resource_Exhaustion__rand_sleep_54_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_54b_badSink(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_54b_goodG2BSink(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_54b_goodB2GSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_54_good	void CWE400_Resource_Exhaustion__rand_sleep_54_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_54b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_54b_badSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54c_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_54b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_54b_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54c_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_54b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_54b_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54c_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_sleep_54c_badSink	void CWE400_Resource_Exhaustion__rand_sleep_54c_badSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54d_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_54c_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_54c_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54d_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_54c_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_54c_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54d_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_sleep_54d_badSink	void CWE400_Resource_Exhaustion__rand_sleep_54d_badSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54e_badSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_54d_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_54d_goodG2BSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54e_goodG2BSink(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_54d_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_54d_goodB2GSink(int count) {     CWE400_Resource_Exhaustion__rand_sleep_54e_goodB2GSink(count); }
1	CWE400_Resource_Exhaustion__rand_sleep_54e_badSink	void CWE400_Resource_Exhaustion__rand_sleep_54e_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_54e_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_54e_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_54e_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_54e_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_61_bad	void CWE400_Resource_Exhaustion__rand_sleep_61_bad() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_sleep_61b_badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_sleep_61b_goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     count = CWE400_Resource_Exhaustion__rand_sleep_61b_goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_61_good	void CWE400_Resource_Exhaustion__rand_sleep_61_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_61b_badSource	int CWE400_Resource_Exhaustion__rand_sleep_61b_badSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
0	CWE400_Resource_Exhaustion__rand_sleep_61b_goodG2BSource	int CWE400_Resource_Exhaustion__rand_sleep_61b_goodG2BSource(int count) {     /* FIX: Use a relatively small number */     count = 20;     return count; }
0	CWE400_Resource_Exhaustion__rand_sleep_61b_goodB2GSource	int CWE400_Resource_Exhaustion__rand_sleep_61b_goodB2GSource(int count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     return count; }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     badSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     goodG2BSource(count);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     goodB2GSource(count);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	badSource	void badSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	goodG2BSource	void goodG2BSource(int &count) {     /* FIX: Use a relatively small number */     count = 20; }
0	goodB2GSource	void goodB2GSource(int &count) {     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	CWE400_Resource_Exhaustion__rand_sleep_63_bad	void CWE400_Resource_Exhaustion__rand_sleep_63_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_63b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_63b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_63b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__rand_sleep_63_good	void CWE400_Resource_Exhaustion__rand_sleep_63_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_63b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_63b_badSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_63b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_63b_goodG2BSink(int * countPtr) {     int count = *countPtr;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_63b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_63b_goodB2GSink(int * countPtr) {     int count = *countPtr;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_64_bad	void CWE400_Resource_Exhaustion__rand_sleep_64_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_64b_badSink(&count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_64b_goodG2BSink(&count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_64b_goodB2GSink(&count); }
0	CWE400_Resource_Exhaustion__rand_sleep_64_good	void CWE400_Resource_Exhaustion__rand_sleep_64_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_64b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_64b_badSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_64b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_64b_goodG2BSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_64b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_64b_goodB2GSink(void * countVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * countPtr = (int *)countVoidPtr;     /* dereference countPtr into count */     int count = (*countPtr);     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_65_bad	void CWE400_Resource_Exhaustion__rand_sleep_65_bad() {     int count;     /* define a function pointer */     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_sleep_65b_badSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* use the function pointer */     funcPtr(count); }
0	goodG2B	static void goodG2B() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_sleep_65b_goodG2BSink;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     funcPtr(count); }
0	goodB2G	static void goodB2G() {     int count;     void (*funcPtr) (int) = CWE400_Resource_Exhaustion__rand_sleep_65b_goodB2GSink;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     funcPtr(count); }
0	CWE400_Resource_Exhaustion__rand_sleep_65_good	void CWE400_Resource_Exhaustion__rand_sleep_65_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_65b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_65b_badSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_65b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_65b_goodG2BSink(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_65b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_65b_goodB2GSink(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_66_bad	void CWE400_Resource_Exhaustion__rand_sleep_66_bad() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* put count in array */     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_sleep_66b_badSink(countArray); }
0	goodG2B	static void goodG2B() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_sleep_66b_goodG2BSink(countArray); }
0	goodB2G	static void goodB2G() {     int count;     int countArray[5];     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countArray[2] = count;     CWE400_Resource_Exhaustion__rand_sleep_66b_goodB2GSink(countArray); }
0	CWE400_Resource_Exhaustion__rand_sleep_66_good	void CWE400_Resource_Exhaustion__rand_sleep_66_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_66b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_66b_badSink(int countArray[]) {     /* copy count out of countArray */     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_66b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_66b_goodG2BSink(int countArray[]) {     int count = countArray[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_66b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_66b_goodB2GSink(int countArray[]) {     int count = countArray[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_67_bad	void CWE400_Resource_Exhaustion__rand_sleep_67_bad() {     int count;     CWE400_Resource_Exhaustion__rand_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_sleep_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int count;     CWE400_Resource_Exhaustion__rand_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_sleep_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int count;     CWE400_Resource_Exhaustion__rand_sleep_67_structType myStruct;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     myStruct.structFirst = count;     CWE400_Resource_Exhaustion__rand_sleep_67b_goodB2GSink(myStruct); }
0	CWE400_Resource_Exhaustion__rand_sleep_67_good	void CWE400_Resource_Exhaustion__rand_sleep_67_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_67b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_67b_badSink(CWE400_Resource_Exhaustion__rand_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_67b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_67b_goodG2BSink(CWE400_Resource_Exhaustion__rand_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_67b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_67b_goodB2GSink(CWE400_Resource_Exhaustion__rand_sleep_67_structType myStruct) {     int count = myStruct.structFirst;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	CWE400_Resource_Exhaustion__rand_sleep_68_bad	void CWE400_Resource_Exhaustion__rand_sleep_68_bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_68_badData = count;     CWE400_Resource_Exhaustion__rand_sleep_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_68_goodG2BData = count;     CWE400_Resource_Exhaustion__rand_sleep_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_68_goodB2GData = count;     CWE400_Resource_Exhaustion__rand_sleep_68b_goodB2GSink(); }
0	CWE400_Resource_Exhaustion__rand_sleep_68_good	void CWE400_Resource_Exhaustion__rand_sleep_68_good() {     goodG2B();     goodB2G(); }
1	CWE400_Resource_Exhaustion__rand_sleep_68b_badSink	void CWE400_Resource_Exhaustion__rand_sleep_68b_badSink() {     int count = CWE400_Resource_Exhaustion__rand_sleep_68_badData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_68b_goodG2BSink	void CWE400_Resource_Exhaustion__rand_sleep_68b_goodG2BSink() {     int count = CWE400_Resource_Exhaustion__rand_sleep_68_goodG2BData;     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_68b_goodB2GSink	void CWE400_Resource_Exhaustion__rand_sleep_68b_goodB2GSink() {     int count = CWE400_Resource_Exhaustion__rand_sleep_68_goodB2GData;     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     badSink(countVector); }
0	goodG2B	static void goodG2B() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a vector */     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodG2BSink(countVector); }
0	goodB2G	static void goodB2G() {     int count;     vector<int> countVector;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     countVector.insert(countVector.end(), 1, count);     goodB2GSink(countVector); }
1	badSink	void badSink(vector<int> countVector) {     /* copy count out of countVector */     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(vector<int> countVector) {     int count = countVector[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(vector<int> countVector) {     int count = countVector[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     badSink(countList); }
0	goodG2B	static void goodG2B() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a list */     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodG2BSink(countList); }
0	goodB2G	static void goodB2G() {     int count;     list<int> countList;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countList.push_back(count);     countList.push_back(count);     countList.push_back(count);     goodB2GSink(countList); }
1	badSink	void badSink(list<int> countList) {     /* copy count out of countList */     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(list<int> countList) {     int count = countList.back();     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(list<int> countList) {     int count = countList.back();     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
1	bad	void bad() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     badSink(countMap); }
0	goodG2B	static void goodG2B() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     /* Put count in a map */     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodG2BSink(countMap); }
0	goodB2G	static void goodB2G() {     int count;     map<int, int> countMap;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     countMap[0] = count;     countMap[1] = count;     countMap[2] = count;     goodB2GSink(countMap); }
1	badSink	void badSink(map<int, int> countMap) {     /* copy count out of countMap */     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodG2BSink	void goodG2BSink(map<int, int> countMap) {     int count = countMap[2];     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	goodB2GSink	void goodB2GSink(map<int, int> countMap) {     int count = countMap[2];     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__rand_sleep_81_bad::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__rand_sleep_81_goodB2G::action(int count) const {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__rand_sleep_81_goodG2B::action(int count) const {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     const CWE400_Resource_Exhaustion__rand_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__rand_sleep_81_bad();     baseObject.action(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     const CWE400_Resource_Exhaustion__rand_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__rand_sleep_81_goodG2B();     baseObject.action(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     const CWE400_Resource_Exhaustion__rand_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__rand_sleep_81_goodB2G();     baseObject.action(count); }
0	action	void CWE400_Resource_Exhaustion__rand_sleep_82_bad::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	action	void CWE400_Resource_Exhaustion__rand_sleep_82_goodB2G::action(int count) {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	action	void CWE400_Resource_Exhaustion__rand_sleep_82_goodG2B::action(int count) {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_sleep_82_bad;     baseObject->action(count);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     /* FIX: Use a relatively small number */     count = 20;     CWE400_Resource_Exhaustion__rand_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_sleep_82_goodG2B;     baseObject->action(count);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32();     CWE400_Resource_Exhaustion__rand_sleep_82_base* baseObject = new CWE400_Resource_Exhaustion__rand_sleep_82_goodB2G;     baseObject->action(count);     delete baseObject; }
1	CWE400_Resource_Exhaustion__rand_sleep_83_bad	CWE400_Resource_Exhaustion__rand_sleep_83_bad::CWE400_Resource_Exhaustion__rand_sleep_83_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	~CWE400_Resource_Exhaustion__rand_sleep_83_bad	CWE400_Resource_Exhaustion__rand_sleep_83_bad::~CWE400_Resource_Exhaustion__rand_sleep_83_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_83_goodB2G	CWE400_Resource_Exhaustion__rand_sleep_83_goodB2G::CWE400_Resource_Exhaustion__rand_sleep_83_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	~CWE400_Resource_Exhaustion__rand_sleep_83_goodB2G	CWE400_Resource_Exhaustion__rand_sleep_83_goodB2G::~CWE400_Resource_Exhaustion__rand_sleep_83_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_83_goodG2B	CWE400_Resource_Exhaustion__rand_sleep_83_goodG2B::CWE400_Resource_Exhaustion__rand_sleep_83_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__rand_sleep_83_goodG2B	CWE400_Resource_Exhaustion__rand_sleep_83_goodG2B::~CWE400_Resource_Exhaustion__rand_sleep_83_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_sleep_83_bad badObject(count); }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_sleep_83_goodG2B goodG2BObject(count); }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_sleep_83_goodB2G goodB2GObject(count); }
1	CWE400_Resource_Exhaustion__rand_sleep_84_bad	CWE400_Resource_Exhaustion__rand_sleep_84_bad::CWE400_Resource_Exhaustion__rand_sleep_84_bad(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
1	~CWE400_Resource_Exhaustion__rand_sleep_84_bad	CWE400_Resource_Exhaustion__rand_sleep_84_bad::~CWE400_Resource_Exhaustion__rand_sleep_84_bad() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
0	CWE400_Resource_Exhaustion__rand_sleep_84_goodB2G	CWE400_Resource_Exhaustion__rand_sleep_84_goodB2G::CWE400_Resource_Exhaustion__rand_sleep_84_goodB2G(int countCopy) {     count = countCopy;     /* POTENTIAL FLAW: Set count to a random value */     count = RAND32(); }
0	~CWE400_Resource_Exhaustion__rand_sleep_84_goodB2G	CWE400_Resource_Exhaustion__rand_sleep_84_goodB2G::~CWE400_Resource_Exhaustion__rand_sleep_84_goodB2G() {     /* FIX: Validate count before using it as a parameter in the sleep function */     if (count > 0 && count <= 2000)     {         SLEEP(count);         printLine("Sleep time OK");     }     else     {         printLine("Sleep time too long");     } }
0	CWE400_Resource_Exhaustion__rand_sleep_84_goodG2B	CWE400_Resource_Exhaustion__rand_sleep_84_goodG2B::CWE400_Resource_Exhaustion__rand_sleep_84_goodG2B(int countCopy) {     count = countCopy;     /* FIX: Use a relatively small number */     count = 20; }
0	~CWE400_Resource_Exhaustion__rand_sleep_84_goodG2B	CWE400_Resource_Exhaustion__rand_sleep_84_goodG2B::~CWE400_Resource_Exhaustion__rand_sleep_84_goodG2B() {     /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */     SLEEP(count);     printLine("Sleep time possibly too long"); }
1	bad	void bad() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_sleep_84_bad * badObject = new CWE400_Resource_Exhaustion__rand_sleep_84_bad(count);     delete badObject; }
0	goodG2B	static void goodG2B() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_sleep_84_goodG2B * goodG2BObject = new CWE400_Resource_Exhaustion__rand_sleep_84_goodG2B(count);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int count;     /* Initialize count */     count = -1;     CWE400_Resource_Exhaustion__rand_sleep_84_goodB2G * goodB2GObject = new CWE400_Resource_Exhaustion__rand_sleep_84_goodB2G(count);     delete goodB2GObject; }
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "
0	SENTENCE	#define SENTENCE "This is the sentence we are printing to the file. "